TYPE "typ_History"
VERSION : 0.1
   STRUCT
      ldt_ts : LDT;
      i_code : Int;
   END_STRUCT;

END_TYPE

TYPE "typ_Workpiece"
VERSION : 0.1
   STRUCT
      s_id : String;
      s_type : String;
      s_state : String;
   END_STRUCT;

END_TYPE

TYPE "typ_Config_Brightness_Sensor"
VERSION : 0.1
   STRUCT
      ldt_ts : LDT;
      x_on : Bool;
      i_fps : Int;
   END_STRUCT;

END_TYPE

TYPE "typ_Environment_Sensor"
VERSION : 0.1
   STRUCT
      ldt_ts : LDT;
      r_t : Real;
      r_rt : Real;
      r_h : Real;
      r_rh : Real;
      r_p : Real;
      i_iaq : Int;
      i_aq : Int;
      di_gr : DInt;
   END_STRUCT;

END_TYPE

TYPE "typ_Brightness_Sensor"
VERSION : 0.1
   STRUCT
      ldt_ts : LDT;
      r_br : Real;
      i_ldr : Int;
   END_STRUCT;

END_TYPE

TYPE "typ_Camera_Picture"
VERSION : 0.1
   STRUCT
      ldt_ts : LDT;
      s_data : String;
   END_STRUCT;

END_TYPE

TYPE "typ_Config_Enviorment_Sensor"
VERSION : 0.1
   STRUCT
      ldt_ts : LDT;
      di_period : DInt;
   END_STRUCT;

END_TYPE

TYPE "typ_Pos_Pan_Tilt_Unit_Enc"
VERSION : 0.1
   STRUCT
      ldt_ts : LDT;
      r_pan : Real;
      r_tilt : Real;
   END_STRUCT;

END_TYPE

TYPE "typ_Alert_Message"
VERSION : 0.1
   STRUCT
      ldt_ts : LDT;
      s_id : String;
      s_data : String;
      i_code : Int;
   END_STRUCT;

END_TYPE

TYPE "typ_State_Client"
VERSION : 0.1
   STRUCT
      ldt_ts : LDT;
      s_station : String;
      i_code : Int;
      s_description : String;
      x_active : Bool;
      s_target : String;
   END_STRUCT;

END_TYPE

TYPE "typ_Stock_Item"
VERSION : 0.1
   STRUCT
      ldt_ts : LDT;
      StockItem { S7_SetPoint := 'False'} : Array[1..3, 1..3] of "typ_Workpiece";
      s_location : String;
   END_STRUCT;

END_TYPE

TYPE "typ_Order_Workpiece_Buttons_State"
VERSION : 0.1
   STRUCT
      ldt_ts : LDT;
      s_state : String;
      s_type : String;
   END_STRUCT;

END_TYPE

TYPE "typ_SPS_Action_Buttons_NFC_Module"
VERSION : 0.1
   STRUCT
      ldt_ts : LDT;
      s_cmd : String;
      Workpiece { S7_SetPoint := 'False'} : "typ_Workpiece";
      History : Array[1..20] of "typ_History";
   END_STRUCT;

END_TYPE

TYPE "typ_NFC_Module_State"
VERSION : 0.1
   STRUCT
      ldt_ts : LDT;
      Workpiece { S7_SetPoint := 'False'} : "typ_Workpiece";
      History : Array[1..20] of "typ_History";
   END_STRUCT;

END_TYPE

TYPE "typ_Axis_Data"
VERSION : 0.1
   STRUCT
      di_Pos_Soft_Switch : DInt := 0;
      di_Neg_Soft_Switch : DInt := 0;
      di_Ref_Pos : DInt := 0;
      di_Loop_Value : DInt := 0;
      di_Pos_Window : DInt := 15;
   END_STRUCT;

END_TYPE

TYPE "typ_SPS_NFC_Module_State"
VERSION : 0.1
   STRUCT
      ldt_ts : LDT;
      Workpiece { S7_SetPoint := 'False'} : "typ_Workpiece";
      History : Array[1..20] of "typ_History";
   END_STRUCT;

END_TYPE

TYPE "typ_Broadcast"
VERSION : 0.1
   STRUCT
      ldt_ts : LDT;
      di_hardwareId : DInt;
      di_hardwareModel : DInt;
      s_softwareName : String;
      di_softwareVersion : DInt;
      s_message : String;
   END_STRUCT;

END_TYPE

TYPE "typ_Order_Workpiece_Buttons"
VERSION : 0.1
   STRUCT
      ldt_ts : LDT;
      s_type : String;
   END_STRUCT;

END_TYPE

TYPE "typ_Action_Buttons_NFC_Module"
VERSION : 0.1
   STRUCT
      ldt_ts : LDT;
      s_cmd : String;
   END_STRUCT;

END_TYPE

TYPE "typ_Pos_Pan_Tilt_Unit_Mov"
VERSION : 0.1
   STRUCT
      ldt_ts : LDT;
      s_cmd : String;
      i_degree : Int;
   END_STRUCT;

END_TYPE

TYPE "typ_Config_Camera_Picture"
VERSION : 0.1
   STRUCT
      ldt_ts : LDT;
      di_period : DInt;
   END_STRUCT;

END_TYPE

TYPE "typ_Axis"
VERSION : 0.1
   STRUCT
      x_Start_Positioning : Bool;
      x_Reference : Bool;
      x_Referenced : Bool;
      x_Position_Reached : Bool;
      di_Target_Position : DInt;
      di_Increment : DInt;
      di_Actual_Position : DInt := 0;
      i_PWM : Int;
      Config { S7_SetPoint := 'False'} : "typ_Axis_Data";
   END_STRUCT;

END_TYPE

TYPE "typ_MQTT_ Interface_TXT_Controler_Publish"
VERSION : 0.1
   STRUCT
      ActionButtonNFCModule { S7_SetPoint := 'False'} : "typ_SPS_Action_Buttons_NFC_Module";
   END_STRUCT;

END_TYPE

TYPE "typ_MQTT_Interface_TXT_Controler_Subscribe"
VERSION : 0.1
   STRUCT
      State_NFC_Device : "typ_SPS_NFC_Module_State";
   END_STRUCT;

END_TYPE

TYPE "typ_Rack_Pos"
VERSION : 0.1
   STRUCT
      di_PosRack_Horizontal : DInt;
      di_PosRack_Vertical : DInt;
   END_STRUCT;

END_TYPE

TYPE "typ_Rack_History"
VERSION : 0.1
   STRUCT
      History : Array[1..20] of "typ_History";
   END_STRUCT;

END_TYPE

TYPE "typ_MQTT_Interface_Dashboard_Subscribe"
VERSION : 0.1
   STRUCT
      EnvironmentSensor { S7_SetPoint := 'False'} : "typ_Environment_Sensor";
      BrightnessSensor : "typ_Brightness_Sensor";
      CameraPicture : "typ_Camera_Picture";
      PosPanTiltUnit : "typ_Pos_Pan_Tilt_Unit_Enc";
      AlertMessage : "typ_Alert_Message";
      Broadcast : "typ_Broadcast";
      State_HBW { S7_SetPoint := 'False'} : "typ_State_Client";
      State_VGR { S7_SetPoint := 'False'} : "typ_State_Client";
      State_MPO { S7_SetPoint := 'False'} : "typ_State_Client";
      State_SLD { S7_SetPoint := 'False'} : "typ_State_Client";
      State_DSI { S7_SetPoint := 'False'} : "typ_State_Client";
      State_DSO { S7_SetPoint := 'False'} : "typ_State_Client";
      Stock_HBW : "typ_Stock_Item";
      State_Order : "typ_Order_Workpiece_Buttons_State";
      State_NFC_Device : "typ_NFC_Module_State";
   END_STRUCT;

END_TYPE

TYPE "typ_MQTT_ Interface_Dashboard_Publish"
VERSION : 0.1
   STRUCT
      ldt_AcknowledgeButton : LDT;
      ConfigRateEnviormentSensor { S7_SetPoint := 'False'} : "typ_Config_Enviorment_Sensor";
      ConfigRateBrightnessSensor { S7_SetPoint := 'False'} : "typ_Config_Brightness_Sensor";
      ConfigRateCameraPicture { S7_SetPoint := 'False'} : "typ_Config_Camera_Picture";
      PosPanTiltUnit : "typ_Pos_Pan_Tilt_Unit_Mov";
      OrderWorkpieceButton { S7_SetPoint := 'False'} : "typ_Order_Workpiece_Buttons";
      ActionButtonNFCModule { S7_SetPoint := 'False'} : "typ_Action_Buttons_NFC_Module";
   END_STRUCT;

END_TYPE

TYPE "typ_VGR"
VERSION : 0.1
   STRUCT
      x_NFC_Start_First : Bool;
      x_NFC_Start : Bool;
      x_NFC_Completed : Bool;
      x_HBW_Storage : Bool;
      x_HBW_Outsource : Bool;
      s_HBW_Outsource_Typ : String;
      x_HBW_Discards : Bool;
      x_HBW_PickedUp : Bool;
      x_MPO_Req_Discard : Bool;
      x_MPO_Discards : Bool;
      x_Ready_For_Outsource : Bool;
      x_State_Process : Bool;
      x_Workpiece_NiO : Bool;
      horizontal_Axis { S7_SetPoint := 'False'} : "typ_Axis";
      vertical_Axis { S7_SetPoint := 'False'} : "typ_Axis";
      rotate_Axis { S7_SetPoint := 'False'} : "typ_Axis";
      Workpiece { S7_SetPoint := 'False'} : "typ_Workpiece";
      History : Array[1..20] of "typ_History";
      di_Pos_DSI_horizontal : DInt;
      di_Pos_DSI_Collect_vertical : DInt;
      di_Pos_DSI_Discard_vertical : DInt;
      di_Offset_Pos_DSI_NFC_vertical : DInt;
      di_Pos_DSI_rotate : DInt;
      di_Pos_DSO_horizontal : DInt;
      di_Pos_DSO_Collect_vertical : DInt;
      di_Pos_DSO_Discard_vertical : DInt;
      di_Offset_Pos_DSO_vertical : DInt;
      di_Pos_DSO_rotate : DInt;
      di_Pos_Color_horizontal : DInt;
      di_Pos_Color_vertical : DInt;
      di_Pos_Color_rotate : DInt;
      di_Pos_NFC_horizontal : DInt;
      di_Pos_NFC_vertical : DInt;
      di_Pos_NFC_rotate : DInt;
      di_Pos_MPO_horizontal : DInt;
      di_Pos_MPO_vertical : DInt;
      di_Offset_Pos_MPO_vertical : DInt;
      di_Pos_MPO_rotate : DInt;
      di_Pos_HBW_horizontal : DInt;
      di_Offset_Pos_HBW_horizontal : DInt;
      di_Pos_HBW_Collect_vertical : DInt;
      di_Pos_HBW_Discard_vertical : DInt;
      di_Offset_Pos_HBW_vertical : DInt;
      di_Pos_HBW_rotate : DInt;
      di_Pos_NiO_horizontal : DInt;
      di_Pos_NiO_vertical : DInt;
      di_Pos_NiO_rotate : DInt;
      di_Pos_SLD_Blue_horizontal : DInt;
      di_Pos_SLD_Blue_vertical : DInt;
      di_Pos_SLD_Blue_rotate : DInt;
      di_Pos_SLD_Red_horizontal : DInt;
      di_Pos_SLD_Red_vertical : DInt;
      di_Pos_SLD_Red_rotate : DInt;
      di_Pos_SLD_White_horizontal : DInt;
      di_Pos_SLD_White_vertical : DInt;
      di_Pos_SLD_White_rotate : DInt;
   END_STRUCT;

END_TYPE

TYPE "typ_MPO"
VERSION : 0.1
   STRUCT
      x_Discard_Ready : Bool;
      x_MPO_Discards_Accepted : Bool;
      x_Error : Bool;
      i_PWM_TurnTable : Int := 700;
      i_PWM_Vacuum : Int := 1000;
      Workpiece { S7_SetPoint := 'False'} : "typ_Workpiece";
      History : Array[1..20] of "typ_History";
   END_STRUCT;

END_TYPE

TYPE "typ_HBW"
VERSION : 0.1
   STRUCT
      x_HBW_PickedUp_Accepted : Bool;
      x_HBW_Discards_Accepted : Bool;
      x_HBW_PickUp_Ready : Bool;
      x_HBW_Container_Available : Bool;
      x_Error : Bool;
      di_PosBelt_Horizontal : DInt;
      di_PosBelt_Vertical : DInt;
      di_Offset_Pos_Belt_Vertical : DInt;
      di_PosRack_A1_Horizontal : DInt;
      di_PosRack_A1_Vertical : DInt;
      di_PosRack_B2_Horizontal : DInt;
      di_PosRack_B2_Vertical : DInt;
      di_PosRack_C3_Horizontal : DInt;
      di_PosRack_C3_Vertical : DInt;
      di_Offset_Pos_Rack_Vertical : DInt;
      i_PWM_ConveyorBelt : Int := 800;
      i_PWM_Cantilever : Int := 800;
      Workpiece { S7_SetPoint := 'False'} : "typ_Workpiece";
      History { S7_SetPoint := 'False'} : Array[1..20] of "typ_History";
      Rack_Pos { S7_SetPoint := 'False'} : Array[1..3, 1..3] of "typ_Rack_Pos";
      Rack_Workpiece { S7_SetPoint := 'False'} : Array[1..3, 1..3] of "typ_Workpiece";
      Rack_History { S7_SetPoint := 'False'} : Array[1..3, 1..3] of "typ_Rack_History";
      Horizontal_Axis { S7_SetPoint := 'False'} : "typ_Axis";
      Vertical_Axis { S7_SetPoint := 'False'} : "typ_Axis";
   END_STRUCT;

END_TYPE

TYPE "typ_SetupAxis"
VERSION : 0.1
   STRUCT
      x_Setup_Activ : Bool;   // Set up calibration active
      i_AxisSelection : Int;   // Number of the axis
      i_Function : Int;   // 0 = automatic, 10 = ref. Travel, 20 = tap, 30 = tap with step width, 40 = start
      x_Set_Ref_Pos : Bool;   // Set reference value
      x_Set_Soft_End_Pos : Bool;   // Set software end positions
      x_Approach_Ref_Pos : Bool;   // Approach reference
      x_Axis_Pos : Bool;   // Axis positiv
      x_Axis_Neg : Bool;   // Axis negative
      x_Approach_Target_Pos : Bool;   // Approach Target position
      w_Increment : Word;   // Increments per step
      i_PWM : Int;   // PWM Signal
      di_Target_Position : DInt;   // Target position
      di_ActualPosition : DInt;   // Actual position
      di_Ref_Pos : DInt;   // Reference position
      di_Actual_Ref_Pos : DInt;   // Current reference position
      di_Soft_End_Pos_Neg : DInt;   // Software end position negative
      di_Actual_Soft_End_Pos_Neg : DInt;   // Current software end position negative
      di_Soft_End_Pos_Pos : DInt;   // Software end position positiv
      di_Actual_Soft_End_Pos_Pos : DInt;   // Current software end position positiv
      di_LoopValue : DInt;   // Loop value
   END_STRUCT;

END_TYPE

TYPE "typ_SSC"
VERSION : 0.1
   STRUCT
      x_Error : Bool;
      di_Pos_Centre_Horizontal : DInt;
      di_Pos_Centre_Vertical : DInt;
      di_Pos_HBW_Horizontal : DInt;
      di_Pos_HBW_Vertical : DInt;
      w_Threshold_White_Red : Word;
      w_Threshold_Red_Blue : Word;
      Horizontal_Axis { S7_SetPoint := 'False'} : "typ_Axis";
      Vertical_Axis { S7_SetPoint := 'False'} : "typ_Axis";
      Workpiece { S7_SetPoint := 'False'} : "typ_Workpiece";
      History : Array[1..20] of "typ_History";
   END_STRUCT;

END_TYPE

TYPE "typ_MQTT_Interface_TXT_Controller"
VERSION : 0.1
   STRUCT
      Subscribe : "typ_MQTT_Interface_TXT_Controler_Subscribe";
      Publish : "typ_MQTT_ Interface_TXT_Controler_Publish";
   END_STRUCT;

END_TYPE

TYPE "typ_SLD"
VERSION : 0.1
   STRUCT
      x_Error : Bool;
      i_CounterValue_Blue : Int := 8;
      i_CounterValue_White : Int := 2;
      i_CounterValue_Red : Int := 4;
      i_Counter_Actual : Int;
      w_Threshold_White_Red : Word;
      w_Threshold_Red_Blue : Word;
      Workpiece { S7_SetPoint := 'False'} : "typ_Workpiece";
      History : Array[1..20] of "typ_History";
   END_STRUCT;

END_TYPE

TYPE "typ_Setup"
VERSION : 0.1
   STRUCT
      x_Clean_Rack_HBW : Bool;
      x_AcknowledgeButton : Bool;
      x_Color_Sensor_Calibration : Bool;
      x_Set_Calib_Value_Color_Blue : Bool;
      x_Set_Calib_Value_Color_White : Bool;
      x_Set_Calib_Value_Color_Red : Bool;
      x_Calculate_Value_Color : Bool;
      i_Color_Sensor_Selection : Int;
      w_Calib_ColorValue_Blue : Word;
      w_Calib_ColorValue_White : Word;
      w_Calib_ColorValue_Red : Word;
      w_Threshold_White_Red : Word;
      w_Threshold_Red_Blue : Word;
      w_Actual_ColorValue : Word;
      x_Set_Pos_Activ : Bool;   // Set up calibration active
      x_Start_Positioning : Bool;
      x_Final_Positioning : Bool;
      x_Home_Positioning : Bool;
      x_Start_Offset : Bool;
      i_Pos_Selection : Int;   // Number of the axis
      di_Pos_Horizontal : DInt;
      di_Pos_Vertical : DInt;
      di_Pos_Rotate : DInt;
      x_Counter_Value_Calibration : Bool;
      i_Calib_CounterValue_Blue : Int := 26;
      i_Calib_CounterValue_White : Int := 5;
      i_Calib_CounterValue_Red : Int := 16;
      x_Set_CounterValues : Bool;
      x_Activate_Continuous_Operation : Bool;
   END_STRUCT;

END_TYPE

TYPE "typ_MQTT_Interface_Dashboard"
VERSION : 0.1
   STRUCT
      Subscribe { S7_SetPoint := 'False'} : "typ_MQTT_Interface_Dashboard_Subscribe";
      Publish : "typ_MQTT_ Interface_Dashboard_Publish";
   END_STRUCT;

END_TYPE

DATA_BLOCK "gtyp_Interface_Dashboard"
TITLE = Global Interface Dashboard Cloud
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
NON_RETAIN
"typ_MQTT_Interface_Dashboard"

BEGIN

END_DATA_BLOCK

FUNCTION_BLOCK "FB_Blinker"
TITLE = Functionblock Blinker
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
   VAR_INPUT 
      int_periodendauer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;
   END_VAR

   VAR_OUTPUT 
      outx_blinker { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR 
      lfb_ton {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      lx_esv_timer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_blinker { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR


BEGIN
	#lfb_ton(IN := NOT #lx_esv_timer,
	        PT := #int_periodendauer / 2,
	        Q => #lx_esv_timer);
	
	IF #lx_esv_timer THEN
	    #lx_blinker := NOT #lx_blinker;
	END_IF;
	
	#outx_blinker := #lx_blinker;
END_FUNCTION_BLOCK

DATA_BLOCK "gtyp_SetupAxis"
TITLE = Global DB Setup Axis
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
NON_RETAIN
"typ_SetupAxis"

BEGIN

END_DATA_BLOCK

FUNCTION_BLOCK "FB_Axis"
TITLE = Functionblock Axis
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
   VAR_INPUT 
      ini_Axis { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      indi_Increment { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      inx_Ref_Switch { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      inx_Start_Positioning { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      inx_Referencing { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ini_PWM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      indi_Target_Position { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
   END_VAR

   VAR_OUTPUT 
      outx_Referenced { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      outx_Position_Reached { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      outx_Motor_Pos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      outx_Motor_Neg { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      outi_Motor_PWM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      outdi_Actual_Position { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
   END_VAR

   VAR_IN_OUT 
      inouttyp_Config : "typ_Axis_Data";
      inouttyp_Setup : "typ_SetupAxis";
   END_VAR

   VAR 
      li_StepCaseSetup { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      li_StepCase { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      lx_Init { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Motor_Neg { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Motor_Pos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Start_TON_Wait { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      li_PWM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ldi_ValueStep { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      ldi_Actual_Position { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      ldi_Actual_Position_Old { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      lfb_R_Trig_Setup {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      lfb_R_Trig_Referencing {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      lfb_TON_Wait {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
   END_VAR


BEGIN
	IF #lx_Init THEN
	    
	    // rising edge set up axis
	    #lfb_R_Trig_Setup(CLK := #inouttyp_Setup.x_Setup_Activ);
	    
	    //Reload when switching to set up
	    IF #lfb_R_Trig_Setup.Q THEN
	        #inouttyp_Setup.di_LoopValue               := #inouttyp_Config.di_Loop_Value;
	        #inouttyp_Setup.di_Ref_Pos                 := 
	        #inouttyp_Setup.di_Actual_Ref_Pos          := #inouttyp_Config.di_Ref_Pos;
	        #inouttyp_Setup.di_Soft_End_Pos_Neg        := 
	        #inouttyp_Setup.di_Actual_Soft_End_Pos_Neg := #inouttyp_Config.di_Neg_Soft_Switch;
	        #inouttyp_Setup.di_Soft_End_Pos_Pos        :=
	        #inouttyp_Setup.di_Actual_Soft_End_Pos_Pos := #inouttyp_Config.di_Pos_Soft_Switch;
	        #inouttyp_Setup.i_PWM                      := #ini_PWM;
	        #inouttyp_Setup.x_Approach_Ref_Pos         := FALSE;
	        #inouttyp_Setup.x_Approach_Target_Pos      := FALSE;
	        #inouttyp_Setup.x_Axis_Neg                 := FALSE;
	        #inouttyp_Setup.x_Axis_Pos                 := FALSE;
	        #inouttyp_Setup.x_Set_Ref_Pos              := FALSE;
	        #inouttyp_Setup.x_Set_Soft_End_Pos         := FALSE;
	    END_IF;
	    
	    #ldi_Actual_Position := #indi_Increment;
	    
	    //rising edge referencing
	    #lfb_R_Trig_Referencing(CLK := #inx_Referencing);
	    
	    //waiting period
	    #lfb_TON_Wait(IN := #lx_Start_TON_Wait,
	                  PT := T#200ms);
	    
	    (**********************************)
	    (******   set up step chain   *****)
	    (**********************************)
	    IF #inouttyp_Setup.i_AxisSelection = #ini_Axis AND #inouttyp_Setup.x_Setup_Activ THEN
	        IF #inouttyp_Setup.x_Approach_Ref_Pos THEN
	            #inouttyp_Setup.i_Function := 10;
	        END_IF;
	        
	        CASE #inouttyp_Setup.i_Function OF
	                
	            0:  // automatic
	                #ldi_Actual_Position_Old := 0;
	                #inouttyp_Setup.x_Approach_Ref_Pos := FALSE;
	                #lx_Start_TON_Wait := FALSE;
	                
	            10: // homing
	                IF #inouttyp_Setup.x_Approach_Ref_Pos THEN
	                    IF NOT #inx_Ref_Switch THEN
	                        #lx_Motor_Neg := TRUE;
	                        #lx_Motor_Pos := FALSE;
	                        #outx_Referenced := FALSE;
	                    END_IF;
	                    
	                    IF #inx_Ref_Switch THEN
	                        #lx_Motor_Neg := TRUE;
	                        #lx_Motor_Pos := TRUE;
	                        
	                        IF #ldi_Actual_Position = #inouttyp_Config.di_Ref_Pos THEN
	                            #inouttyp_Setup.x_Approach_Ref_Pos := FALSE;
	                            #lx_Motor_Neg       := FALSE;
	                            #lx_Motor_Pos       := FALSE;
	                            #outx_Referenced    := TRUE;
	                        END_IF;
	                    END_IF;
	                END_IF;
	                
	            20:  // tap
	                #lx_Motor_Neg := #inouttyp_Setup.x_Axis_Neg AND NOT #inx_Ref_Switch AND NOT (#ldi_Actual_Position <= #inouttyp_Setup.di_Soft_End_Pos_Neg);
	                #lx_Motor_Pos := #inouttyp_Setup.x_Axis_Pos AND NOT #lx_Motor_Neg AND NOT (#ldi_Actual_Position >= #inouttyp_Setup.di_Soft_End_Pos_Pos);
	                
	            30:  // tap with increment
	                #ldi_Actual_Position_Old := #ldi_Actual_Position;
	                
	                // positiv
	                IF #inouttyp_Setup.x_Axis_Pos AND NOT ((#ldi_Actual_Position + #inouttyp_Setup.w_Increment + #inouttyp_Setup.di_LoopValue) >= #inouttyp_Setup.di_Soft_End_Pos_Pos) THEN
	                    #lx_Motor_Neg := FALSE;
	                    #lx_Motor_Pos := TRUE;
	                    #ldi_ValueStep := #ldi_Actual_Position_Old + #inouttyp_Setup.w_Increment;
	                    
	                    // without loop
	                    IF (#inouttyp_Setup.di_LoopValue = 0) THEN
	                        #inouttyp_Setup.i_Function := 36;
	                    ELSE
	                        #inouttyp_Setup.i_Function := 31;
	                    END_IF;
	                // negativ
	                ELSIF #inouttyp_Setup.x_Axis_Neg AND NOT ((#ldi_Actual_Position - #inouttyp_Setup.w_Increment) <= #inouttyp_Config.di_Neg_Soft_Switch) THEN
	                    #lx_Motor_Neg := TRUE;
	                    #lx_Motor_Pos := FALSE;
	                    #ldi_ValueStep := #ldi_Actual_Position_Old - #inouttyp_Setup.w_Increment;
	                    #inouttyp_Setup.i_Function := 34;
	                END_IF;
	                
	            31: // with loop
	                IF ((#ldi_Actual_Position >= (#ldi_ValueStep + #inouttyp_Setup.di_LoopValue - #inouttyp_Config.di_Pos_Window)) = 0) THEN
	                    #lx_Motor_Neg := TRUE;
	                    #lx_Motor_Pos := TRUE;
	                    #inouttyp_Setup.i_Function := 32;
	                END_IF;
	                
	            32: // wait sequence
	                #lx_Start_TON_Wait := TRUE;
	                
	                IF #lfb_TON_Wait.Q THEN
	                    #lx_Motor_Neg               := FALSE;
	                    #lx_Motor_Pos               := FALSE;
	                    #lx_Start_TON_Wait          := FALSE;
	                    #inouttyp_Setup.i_Function  := 33;
	                END_IF;
	                
	            33: // change direction
	                #lx_Motor_Neg := TRUE;
	                #lx_Motor_Pos := FALSE;
	                #inouttyp_Setup.i_Function := 34;
	                
	            34: // position reached negativ
	                IF (#ldi_Actual_Position <= (#ldi_ValueStep + #inouttyp_Config.di_Pos_Window))
	                    AND (#ldi_Actual_Position >= (#ldi_ValueStep - #inouttyp_Config.di_Pos_Window)) THEN
	                    #lx_Motor_Neg := TRUE;
	                    #lx_Motor_Pos := TRUE;
	                    #inouttyp_Setup.i_Function := 35;
	                END_IF;
	                
	            35: // wait sequence
	                #lx_Start_TON_Wait := TRUE;
	                
	                IF #lfb_TON_Wait.Q THEN
	                    #lx_Motor_Neg := FALSE;
	                    #lx_Motor_Pos := FALSE;
	                    #lx_Start_TON_Wait := FALSE;
	                    #inouttyp_Setup.x_Axis_Neg := FALSE;
	                    #inouttyp_Setup.x_Axis_Pos := FALSE;
	                    #inouttyp_Setup.i_Function := 30;
	                END_IF;
	                    
	                
	            36: // position reached positiv
	                IF (#ldi_Actual_Position <= (#ldi_ValueStep + #inouttyp_Config.di_Pos_Window))
	                    AND (#ldi_Actual_Position >= (#ldi_ValueStep - #inouttyp_Config.di_Pos_Window)) THEN
	                    #lx_Motor_Neg := TRUE;
	                    #lx_Motor_Pos := TRUE;
	                    #inouttyp_Setup.i_Function := 37;
	                END_IF;
	            
	            37: // wait sequence
	                #lx_Start_TON_Wait := TRUE;
	            
	                IF #lfb_TON_Wait.Q THEN
	                    #lx_Motor_Neg := FALSE;
	                    #lx_Motor_Pos := FALSE;
	                    #lx_Start_TON_Wait := FALSE;
	                    #inouttyp_Setup.x_Axis_Neg := FALSE;
	                    #inouttyp_Setup.x_Axis_Pos := FALSE;
	                    #inouttyp_Setup.i_Function := 30;
	                END_IF;
	                
	            40: // approach position
	                IF #inouttyp_Setup.x_Approach_Target_Pos THEN
	                    // positiv
	                    IF (#inouttyp_Setup.di_Target_Position > #ldi_Actual_Position) AND NOT ((#inouttyp_Setup.di_Target_Position + #inouttyp_Setup.di_LoopValue) >= #inouttyp_Setup.di_Soft_End_Pos_Pos)  THEN
	                        #lx_Motor_Neg := FALSE;
	                        #lx_Motor_Pos := TRUE;
	                        // without loop
	                        IF (#inouttyp_Setup.di_LoopValue = 0) THEN
	                            #inouttyp_Setup.i_Function := 46;
	                        ELSE
	                            #inouttyp_Setup.i_Function := 41;
	                        END_IF;
	                    // negativ
	                    ELSIF ((#inouttyp_Setup.di_Target_Position < #ldi_Actual_Position) AND NOT (#inouttyp_Setup.di_Target_Position <= #inouttyp_Config.di_Neg_Soft_Switch))  THEN
	                        #lx_Motor_Neg := TRUE;
	                        #lx_Motor_Pos := FALSE;
	                        #inouttyp_Setup.i_Function := 44;
	                    ELSIF (#inouttyp_Setup.di_Target_Position = #ldi_Actual_Position) THEN
	                        #inouttyp_Setup.i_Function := 46;
	                    END_IF;
	                    
	                END_IF;
	                
	            41: // with loop
	                IF (#ldi_Actual_Position >= (#inouttyp_Setup.di_Target_Position + #inouttyp_Setup.di_LoopValue - #inouttyp_Config.di_Pos_Window)) THEN
	                    #lx_Motor_Neg := TRUE;
	                    #lx_Motor_Pos := TRUE;
	                    #inouttyp_Setup.i_Function := 42;
	                END_IF;
	                
	            42: // wait sequence
	                #lx_Start_TON_Wait := TRUE;
	                
	                IF #lfb_TON_Wait.Q THEN
	                    #lx_Motor_Neg := FALSE;
	                    #lx_Motor_Pos := FALSE;
	                    #lx_Start_TON_Wait := FALSE;
	                    #inouttyp_Setup.i_Function := 43;
	                END_IF;
	                
	            43: // change direction
	                #lx_Motor_Neg   := TRUE;
	                #lx_Motor_Pos   := FALSE;
	                #inouttyp_Setup.i_Function     := 44;
	            
	            44: // position reached negativ
	                IF (#ldi_Actual_Position <= (#inouttyp_Setup.di_Target_Position + #inouttyp_Config.di_Pos_Window))
	                    AND (#ldi_Actual_Position >= (#inouttyp_Setup.di_Target_Position - #inouttyp_Config.di_Pos_Window)) THEN
	                    #lx_Motor_Neg := TRUE;
	                    #lx_Motor_Pos := TRUE;
	                    #inouttyp_Setup.i_Function := 45;
	                END_IF;
	                
	            45: // wait sequence
	                #lx_Start_TON_Wait := TRUE;
	                
	                IF #lfb_TON_Wait.Q THEN
	                    #lx_Motor_Neg := FALSE;
	                    #lx_Motor_Pos := FALSE;
	                    #lx_Start_TON_Wait := FALSE;
	                    #inouttyp_Setup.x_Axis_Neg := FALSE;
	                    #inouttyp_Setup.x_Axis_Pos := FALSE;
	                    #inouttyp_Setup.i_Function := 40;
	                END_IF;
	                
	            46: //  position reached positiv
	                IF (#ldi_Actual_Position <= (#inouttyp_Setup.di_Target_Position + #inouttyp_Config.di_Pos_Window))
	                    AND (#ldi_Actual_Position >= (#inouttyp_Setup.di_Target_Position - #inouttyp_Config.di_Pos_Window)) THEN
	                    #lx_Motor_Neg := TRUE;
	                    #lx_Motor_Pos := TRUE;
	                    #inouttyp_Setup.i_Function := 47;
	                END_IF;
	                
	            47:  // wait sequence
	                #lx_Start_TON_Wait := TRUE;
	                
	                IF #lfb_TON_Wait.Q THEN
	                    #lx_Motor_Neg := FALSE;
	                    #lx_Motor_Pos := FALSE;
	                    #lx_Start_TON_Wait := FALSE;
	                    #inouttyp_Setup.x_Approach_Target_Pos := FALSE;
	                    #inouttyp_Setup.i_Function := 40;
	                END_IF;
	            ELSE  // Statement section ELSE
	                ;
	        END_CASE;
	        
	        // set reference point
	        IF #inouttyp_Setup.x_Set_Ref_Pos THEN
	            #inouttyp_Setup.di_Actual_Ref_Pos   :=
	            #inouttyp_Config.di_Ref_Pos         := #inouttyp_Setup.di_Ref_Pos;
	            #inouttyp_Setup.x_Set_Ref_Pos       := FALSE;
	        END_IF;
	        
	        // set software end position
	        IF #inouttyp_Setup.x_Set_Soft_End_Pos THEN
	            #inouttyp_Setup.di_Actual_Soft_End_Pos_Neg  :=
	            #inouttyp_Config.di_Neg_Soft_Switch         := #inouttyp_Setup.di_Soft_End_Pos_Neg;
	            #inouttyp_Setup.di_Actual_Soft_End_Pos_Pos  :=
	            #inouttyp_Config.di_Pos_Soft_Switch         := #inouttyp_Setup.di_Soft_End_Pos_Pos;
	            #inouttyp_Setup.x_Set_Soft_End_Pos := FALSE;
	        END_IF;
	        
	        // reload PWM
	        #li_PWM := #inouttyp_Setup.i_PWM;
	        
	        // reload actual position
	        #inouttyp_Setup.di_ActualPosition           := #ldi_Actual_Position;
	
	    (************************************)
	    (******   position step chain   *****)
	    (************************************)
	    ELSIF NOT #inouttyp_Setup.x_Setup_Activ THEN
	                
	        // rising edge set up axis
	        IF #lfb_R_Trig_Referencing.Q THEN
	            #li_StepCase := 0;
	        END_IF;
	                
	        CASE #li_StepCase OF
	                
	            0:  // init
	                #lx_Start_TON_Wait := FALSE;
	                
	                IF #inx_Referencing THEN
	                    #li_StepCase            := 10;
	                    #outx_Position_Reached  := FALSE;
	                    #outx_Referenced        := FALSE;
	                ELSIF #inx_Start_Positioning THEN
	                    #li_StepCase            := 20;
	                    #outx_Position_Reached  := FALSE;
	                END_IF;
	                
	            10: // homing
	                IF NOT #inx_Ref_Switch THEN
	                    #lx_Motor_Neg := TRUE;
	                    #lx_Motor_Pos := FALSE;
	                END_IF;
	                
	                IF #inx_Ref_Switch THEN
	                    #lx_Motor_Neg := TRUE;
	                    #lx_Motor_Pos := TRUE;
	                    
	                    IF #inx_Ref_Switch THEN
	                        IF #ldi_Actual_Position = #inouttyp_Config.di_Ref_Pos THEN
	                            #lx_Motor_Neg := FALSE;
	                            #lx_Motor_Pos := FALSE;
	                            #outx_Referenced := TRUE;
	                            #li_StepCase := 11;
	                        END_IF;
	                    END_IF;
	                END_IF;
	                
	            11: // wait not referencing
	                IF NOT #inx_Referencing THEN
	                    #li_StepCase := 0;
	                END_IF;
	                
	            20: // approach position
	                // positiv
	                IF (#indi_Target_Position > #ldi_Actual_Position) AND NOT ((#indi_Target_Position + #inouttyp_Config.di_Loop_Value) >= #inouttyp_Config.di_Pos_Soft_Switch) THEN
	                    #lx_Motor_Neg := FALSE;
	                    #lx_Motor_Pos := TRUE;
	                    //without loop
	                    IF (#inouttyp_Config.di_Loop_Value = 0) THEN
	                        #li_StepCase := 26;
	                    ELSE
	                        #li_StepCase := 21;
	                    END_IF;
	                // negativ
	                ELSIF ((#indi_Target_Position < #ldi_Actual_Position) AND NOT (#indi_Target_Position <= #inouttyp_Config.di_Neg_Soft_Switch)) THEN
	                    #lx_Motor_Neg := TRUE;
	                    #lx_Motor_Pos := FALSE;
	                    #li_StepCase := 24;
	                ELSIF (#indi_Target_Position = #ldi_Actual_Position) THEN
	                    #li_StepCase := 26;
	                END_IF;
	                
	            21: // with loop
	                IF (#ldi_Actual_Position >= (#indi_Target_Position + #inouttyp_Config.di_Loop_Value - #inouttyp_Config.di_Pos_Window)) THEN
	                    #lx_Motor_Neg := TRUE;
	                    #lx_Motor_Pos := TRUE;
	                    #li_StepCase := 22;
	                END_IF;
	                
	            22: // wait sequence
	                #lx_Start_TON_Wait := TRUE;
	                
	                IF #lfb_TON_Wait.Q THEN
	                    #lx_Motor_Neg := FALSE;
	                    #lx_Motor_Pos := FALSE;
	                    #lx_Start_TON_Wait := FALSE;
	                    #inouttyp_Setup.i_Function := 23;
	                END_IF;
	                  
	            23: // change direction
	                #lx_Motor_Neg := TRUE;
	                #lx_Motor_Pos := FALSE;
	                #li_StepCase := 24;
	                
	            24: // position reached negativ
	                IF (#ldi_Actual_Position <= (#indi_Target_Position + #inouttyp_Config.di_Pos_Window))
	                    AND (#ldi_Actual_Position >= (#indi_Target_Position - #inouttyp_Config.di_Pos_Window)) THEN
	                    #lx_Motor_Neg := TRUE;
	                    #lx_Motor_Pos := TRUE;
	                    #li_StepCase := 25;
	                END_IF;
	                
	            25: // wait sequence
	                #lx_Start_TON_Wait := TRUE;
	                
	                IF #lfb_TON_Wait.Q THEN
	                    #lx_Motor_Neg := FALSE;
	                    #lx_Motor_Pos := FALSE;
	                    #lx_Start_TON_Wait := FALSE;
	                    #outx_Position_Reached := TRUE;
	                    #li_StepCase := 28;
	                END_IF;
	                
	            26: // position reached positiv
	                IF (#ldi_Actual_Position <= (#indi_Target_Position + #inouttyp_Config.di_Pos_Window))
	                    AND (#ldi_Actual_Position >= (#indi_Target_Position - #inouttyp_Config.di_Pos_Window)) THEN
	                    #lx_Motor_Neg := TRUE;
	                    #lx_Motor_Pos := TRUE;
	                    #li_StepCase := 27;
	                END_IF;
	                
	            27: // wait sequence
	                #lx_Start_TON_Wait := TRUE;
	                
	                IF #lfb_TON_Wait.Q THEN
	                    #lx_Motor_Neg := FALSE;
	                    #lx_Motor_Pos := FALSE;
	                    #lx_Start_TON_Wait := FALSE;
	                    #outx_Position_Reached := TRUE;
	                    #li_StepCase := 28;
	                END_IF;
	                
	            28: // wait not start positioning
	                IF NOT #inx_Start_Positioning THEN
	                    #li_StepCase := 0;
	                END_IF;
	            // statement section ELSE    
	            ELSE  
	                ;
	        END_CASE;
	        
	        // reload PWM
	        #li_PWM := #ini_PWM;
	    END_IF;
	    
	    // reload outputs
	    #outx_Motor_Neg         := #lx_Motor_Neg;
	    #outx_Motor_Pos         := #lx_Motor_Pos;
	    #outi_Motor_PWM         := #li_PWM;
	    #outdi_Actual_Position  := #ldi_Actual_Position;
	    
	ELSE
	    #lx_Init := TRUE;
	END_IF;
END_FUNCTION_BLOCK

DATA_BLOCK "gtyp_Interface_TXT_Controler"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"typ_MQTT_Interface_TXT_Controller"

BEGIN

END_DATA_BLOCK

FUNCTION "FC_Scale_linear" : Real
TITLE = Function scale linear
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
   VAR_INPUT 
      inr_Y1 : Real;   // Initial scaling value for Y (INPUT)
      inr_Y2 : Real;   // Scaling end value for Y (INPUT)
      inr_X1 : Real;   // Initial scaling value for X (INPUT)
      inr_X2 : Real;   // Scaling end value for X (INPUT)
      inr_X : Real;   // Value to be scaled
   END_VAR

   VAR_TEMP 
      lr_y_delta : Real;   // Temp delta y
      lr_x_delta : Real;   // Temp delta x
      lr_m : Real;   // Temp gradient m
   END_VAR


BEGIN
	(********************************************************)
	(* FC for linear scaling. Line function  y=m*(x-x1)+y1  *)
	(********************************************************)
	
	#lr_y_delta := (#inr_Y2 - #inr_Y1);
	#lr_x_delta := (#inr_X2 - #inr_X1);
	
	IF #lr_y_delta <> 0 AND #lr_x_delta <> 0 THEN
	    #lr_m := (#lr_y_delta / #lr_x_delta);
	    #FC_Scale_linear := (#lr_m * (#inr_X - #inr_X1)) + #inr_Y1;
	ELSE
	    #FC_Scale_linear := 0;
	END_IF;
END_FUNCTION

DATA_BLOCK "gtyp_MPO"
TITLE = Global DB MPO
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
NON_RETAIN
"typ_MPO"

BEGIN

END_DATA_BLOCK

DATA_BLOCK "gtyp_Setup"
TITLE = Global DB Setup
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
NON_RETAIN
"typ_Setup"

BEGIN

END_DATA_BLOCK

DATA_BLOCK "gtyp_VGR"
TITLE = Global DB VGR
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
NON_RETAIN
"typ_VGR"

BEGIN
   horizontal_Axis.i_PWM := 500;
   horizontal_Axis.Config.di_Pos_Soft_Switch := 20000;
   horizontal_Axis.Config.di_Neg_Soft_Switch := 0;
   horizontal_Axis.Config.di_Ref_Pos := 0;
   horizontal_Axis.Config.di_Loop_Value := 0;
   vertical_Axis.i_PWM := 500;
   vertical_Axis.Config.di_Pos_Soft_Switch := 20000;
   vertical_Axis.Config.di_Neg_Soft_Switch := 0;
   vertical_Axis.Config.di_Ref_Pos := 0;
   vertical_Axis.Config.di_Loop_Value := 0;
   rotate_Axis.i_PWM := 500;
   rotate_Axis.Config.di_Pos_Soft_Switch := 20000;
   rotate_Axis.Config.di_Neg_Soft_Switch := 0;
   rotate_Axis.Config.di_Ref_Pos := 0;
   rotate_Axis.Config.di_Loop_Value := 0;
   di_Pos_DSI_horizontal := 20;
   di_Pos_DSI_Collect_vertical := 2950;
   di_Offset_Pos_DSI_NFC_vertical := 1200;
   di_Pos_DSI_rotate := 30;
   di_Pos_DSO_horizontal := 2070;
   di_Pos_DSO_Discard_vertical := 1480;
   di_Pos_DSO_rotate := 970;
   di_Pos_Color_horizontal := 150;
   di_Pos_Color_vertical := 2450;
   di_Pos_Color_rotate := 430;
   di_Pos_NFC_horizontal := 900;
   di_Pos_NFC_vertical := 2450;
   di_Pos_NFC_rotate := 700;
   di_Pos_MPO_horizontal := 3400;
   di_Pos_MPO_vertical := 1800;
   di_Offset_Pos_MPO_vertical := 650;
   di_Pos_MPO_rotate := 3500;
   di_Pos_HBW_horizontal := 600;
   di_Offset_Pos_HBW_horizontal := 0;
   di_Pos_HBW_Collect_vertical := 650;
   di_Pos_HBW_Discard_vertical := 200;
   di_Offset_Pos_HBW_vertical := 0;
   di_Pos_HBW_rotate := 5350;
   di_Pos_NiO_horizontal := 0;
   di_Pos_NiO_vertical := 2700;
   di_Pos_NiO_rotate := 1100;
   di_Pos_SLD_Blue_horizontal := 2150;
   di_Pos_SLD_Blue_vertical := 3100;
   di_Pos_SLD_Blue_rotate := 1200;
   di_Pos_SLD_Red_horizontal := 1580;
   di_Pos_SLD_Red_vertical := 3100;
   di_Pos_SLD_Red_rotate := 1460;
   di_Pos_SLD_White_horizontal := 1370;
   di_Pos_SLD_White_vertical := 3100;
   di_Pos_SLD_White_rotate := 1770;

END_DATA_BLOCK

DATA_BLOCK "gtyp_SLD"
TITLE = Global DB SLD
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
NON_RETAIN
"typ_SLD"

BEGIN
   i_CounterValue_Blue := 26;
   i_CounterValue_White := 5;
   i_CounterValue_Red := 16;
   w_Threshold_White_Red := 16#2698;
   w_Threshold_Red_Blue := 16#3D41;

END_DATA_BLOCK

DATA_BLOCK "gtyp_SSC"
TITLE = Global DB SSC
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
NON_RETAIN
"typ_SSC"

BEGIN
   di_Pos_Centre_Horizontal := 3000;
   di_Pos_Centre_Vertical := 1400;
   di_Pos_HBW_Horizontal := 5400;
   di_Pos_HBW_Vertical := 950;
   w_Threshold_White_Red := 16#25DA;
   w_Threshold_Red_Blue := 16#3C57;
   Horizontal_Axis.i_PWM := 1000;
   Horizontal_Axis.Config.di_Pos_Soft_Switch := 5450;
   Horizontal_Axis.Config.di_Neg_Soft_Switch := 0;
   Horizontal_Axis.Config.di_Ref_Pos := 0;
   Horizontal_Axis.Config.di_Loop_Value := 0;
   Horizontal_Axis.Config.di_Pos_Window := 25;
   Vertical_Axis.i_PWM := 1000;
   Vertical_Axis.Config.di_Pos_Soft_Switch := 3000;
   Vertical_Axis.Config.di_Neg_Soft_Switch := 0;
   Vertical_Axis.Config.di_Ref_Pos := 0;
   Vertical_Axis.Config.di_Loop_Value := 0;
   Vertical_Axis.Config.di_Pos_Window := 25;

END_DATA_BLOCK

DATA_BLOCK "gtyp_HBW"
TITLE = Global DB HBW
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
"typ_HBW"

BEGIN
   di_PosBelt_Horizontal := 18;
   di_PosBelt_Vertical := 2800;
   di_Offset_Pos_Belt_Vertical := 370;
   di_PosRack_A1_Horizontal := 2870;
   di_PosRack_A1_Vertical := 400;
   di_PosRack_B2_Horizontal := 5200;
   di_PosRack_B2_Vertical := 1750;
   di_PosRack_C3_Horizontal := 7560;
   di_PosRack_C3_Vertical := 3250;
   di_Offset_Pos_Rack_Vertical := 370;
   i_PWM_Cantilever := 1000;
   Rack_Pos[1,1].di_PosRack_Horizontal := 2870;
   Rack_Pos[1,1].di_PosRack_Vertical := 400;
   Rack_Pos[1,2].di_PosRack_Horizontal := 5200;
   Rack_Pos[1,2].di_PosRack_Vertical := 400;
   Rack_Pos[1,3].di_PosRack_Horizontal := 7550;
   Rack_Pos[1,3].di_PosRack_Vertical := 400;
   Rack_Pos[2,1].di_PosRack_Horizontal := 2870;
   Rack_Pos[2,1].di_PosRack_Vertical := 1750;
   Rack_Pos[2,2].di_PosRack_Horizontal := 5200;
   Rack_Pos[2,2].di_PosRack_Vertical := 1750;
   Rack_Pos[2,3].di_PosRack_Horizontal := 7550;
   Rack_Pos[2,3].di_PosRack_Vertical := 1750;
   Rack_Pos[3,1].di_PosRack_Horizontal := 2870;
   Rack_Pos[3,1].di_PosRack_Vertical := 3150;
   Rack_Pos[3,2].di_PosRack_Horizontal := 5200;
   Rack_Pos[3,2].di_PosRack_Vertical := 3150;
   Rack_Pos[3,3].di_PosRack_Horizontal := 7550;
   Rack_Pos[3,3].di_PosRack_Vertical := 3150;
   Rack_Workpiece[1,1].s_id := '0';
   Rack_Workpiece[1,2].s_id := '0';
   Rack_Workpiece[1,3].s_id := '0';
   Rack_Workpiece[2,1].s_id := '0';
   Rack_Workpiece[2,2].s_id := '0';
   Rack_Workpiece[2,3].s_id := '0';
   Rack_Workpiece[3,1].s_id := '0';
   Rack_Workpiece[3,2].s_id := '0';
   Rack_Workpiece[3,3].s_id := '0';
   Horizontal_Axis.i_PWM := 700;
   Horizontal_Axis.Config.di_Pos_Soft_Switch := 7900;
   Horizontal_Axis.Config.di_Neg_Soft_Switch := 0;
   Horizontal_Axis.Config.di_Ref_Pos := 0;
   Horizontal_Axis.Config.di_Loop_Value := 0;
   Horizontal_Axis.Config.di_Pos_Window := 15;
   Vertical_Axis.i_PWM := 600;
   Vertical_Axis.Config.di_Pos_Soft_Switch := 3350;
   Vertical_Axis.Config.di_Neg_Soft_Switch := 0;
   Vertical_Axis.Config.di_Ref_Pos := 0;
   Vertical_Axis.Config.di_Loop_Value := 0;
   Vertical_Axis.Config.di_Pos_Window := 15;

END_DATA_BLOCK

FUNCTION_BLOCK "PRG_SSC_Light"
TITLE = Program Lights
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
   VAR 
      lx_Init { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Start { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      li_StepCase { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ldt_MQTT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Date_And_Time;
      lldt_ts_old { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LDT;
      li_Return_LDT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      lfb_TOF_Camera {InstructionName := 'TOF_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TOF_TIME;
      lfb_TON_Schritt {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      lfb_blinker_cam { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Blinker";
      lfb_blinker_config { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Blinker";
      lx_StartTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR


BEGIN
	IF #lx_Init THEN
	    
	    // if camera sen picture - Red light flash
	    IF "gtyp_Interface_Dashboard".Subscribe.CameraPicture.ldt_ts > #lldt_ts_old THEN
	        #lldt_ts_old := "gtyp_Interface_Dashboard".Subscribe.CameraPicture.ldt_ts;
	        #lfb_blinker_cam(int_periodendauer := T#50ms);
	    END_IF;
	    
	    // reload flash
	    "QX_SSC_LED_Red_Online_Q8":= #lfb_blinker_cam.outx_blinker;
	    
	    // FB flash config
	    #lfb_blinker_config(int_periodendauer := T#500ms);
	    
	    //  Deciding which state
	    //  Setup - Calibration State
	    IF "gtyp_Setup".x_Set_Pos_Activ OR "gtyp_Setup".x_Clean_Rack_HBW THEN
	        "QX_SSC_LED_Green_Q5"  := #lfb_blinker_config.outx_blinker;
	        "QX_SSC_LED_Yellow_Q6" := #lfb_blinker_config.outx_blinker;
	        "QX_SSC_LED_Red_Q7"    := #lfb_blinker_config.outx_blinker;
	    //  Error State
	    ELSIF ("gtyp_Interface_Dashboard".Subscribe.State_HBW.i_code = 4)
	        OR ("gtyp_Interface_Dashboard".Subscribe.State_MPO.i_code = 4)
	        OR ("gtyp_Interface_Dashboard".Subscribe.State_SLD.i_code = 4)
	        OR ("gtyp_Interface_Dashboard".Subscribe.State_VGR.i_code = 4) THEN
	        "QX_SSC_LED_Green_Q5" := FALSE;
	        "QX_SSC_LED_Yellow_Q6" := FALSE;
	        "QX_SSC_LED_Red_Q7" := TRUE;
	    //  Proccessing State
	    ELSIF ("gtyp_Interface_Dashboard".Subscribe.State_HBW.i_code = 2)
	        OR ("gtyp_Interface_Dashboard".Subscribe.State_MPO.i_code = 2)
	        OR ("gtyp_Interface_Dashboard".Subscribe.State_SLD.i_code = 2)
	        OR ("gtyp_Interface_Dashboard".Subscribe.State_VGR.i_code = 2) THEN
	            "QX_SSC_LED_Green_Q5" := FALSE;
	            "QX_SSC_LED_Yellow_Q6" := TRUE;
	            "QX_SSC_LED_Red_Q7" := FALSE;
	    //  Idle State
	    ELSIF ("gtyp_Interface_Dashboard".Subscribe.State_HBW.i_code = 1)
	        AND ("gtyp_Interface_Dashboard".Subscribe.State_MPO.i_code = 1)
	        AND ("gtyp_Interface_Dashboard".Subscribe.State_SLD.i_code = 1)
	        AND ("gtyp_Interface_Dashboard".Subscribe.State_VGR.i_code = 1) THEN
	            "QX_SSC_LED_Green_Q5" := TRUE;
	            "QX_SSC_LED_Yellow_Q6" := FALSE;
	            "QX_SSC_LED_Red_Q7" := FALSE;
	    //  nothing State
	    ELSE
	        "QX_SSC_LED_Green_Q5" := FALSE;
	        "QX_SSC_LED_Yellow_Q6" := FALSE;
	        "QX_SSC_LED_Red_Q7" := FALSE;
	    END_IF;
	    
	    
	ELSE
	    #lx_Init := TRUE;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "PRG_SSC_Calibration_Color"
TITLE = Program Calibration Color Sensor SSC
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
   VAR 
      lx_Init { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Start_TON_Wait { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Start_Positioning_m { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lt_TON_Wait { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;
      li_StepCase { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ldi_Pos_Horizontal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      ldi_Pos_Vertical { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      lfb_R_Trig_Deaktivate {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      lfb_TON_Wait {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
   END_VAR


BEGIN
	IF #lx_Init THEN
	    
	    // FB TON Wait
	    #lfb_TON_Wait(IN := #lx_Start_TON_Wait,
	                  PT := #lt_TON_Wait);
	    
	    #lfb_R_Trig_Deaktivate(CLK:= NOT "gtyp_Setup".x_Color_Sensor_Calibration
	                           OR NOT ("gtyp_Setup".i_Color_Sensor_Selection = 1));
	    // Deaktivate step 0   
	    IF #lfb_R_Trig_Deaktivate.Q THEN
	        "gtyp_Setup".x_Calculate_Value_Color := FALSE;
	        "gtyp_Setup".x_Set_Calib_Value_Color_Blue := FALSE;
	        "gtyp_Setup".x_Set_Calib_Value_Color_Red := FALSE;
	        "gtyp_Setup".x_Set_Calib_Value_Color_White := FALSE;
	        "gtyp_Setup".w_Calib_ColorValue_Blue := 0;
	        "gtyp_Setup".w_Calib_ColorValue_Red := 0;
	        "gtyp_Setup".w_Calib_ColorValue_White := 0;
	        "gtyp_Setup".w_Threshold_Red_Blue := 0;
	        "gtyp_Setup".w_Threshold_White_Red := 0;
	        #li_StepCase            := 0;
	    END_IF;
	    
	    // step chain HBW
	    CASE #li_StepCase OF
	            
	        0:  // init
	            #lx_Start_TON_Wait := FALSE;
	            #li_StepCase := 10;
	            
	        10:  // Set Calibration activ?
	            IF "gtyp_Setup".x_Color_Sensor_Calibration
	                AND ("gtyp_Setup".i_Color_Sensor_Selection = 1) THEN
	                "gtyp_Setup".x_Calculate_Value_Color := FALSE;
	                "gtyp_Setup".x_Set_Calib_Value_Color_Blue := FALSE;
	                "gtyp_Setup".x_Set_Calib_Value_Color_Red := FALSE;
	                "gtyp_Setup".x_Set_Calib_Value_Color_White := FALSE;
	                "gtyp_Setup".w_Calib_ColorValue_Blue := 0;
	                "gtyp_Setup".w_Calib_ColorValue_Red := 0;
	                "gtyp_Setup".w_Calib_ColorValue_White := 0;
	                "gtyp_Setup".w_Threshold_Red_Blue := 0;
	                "gtyp_Setup".w_Threshold_White_Red := 0;
	                #li_StepCase := 20;
	            END_IF;
	            
	        20: // wait for set Values or Calculate
	            
	            // Start new Positioning
	            IF "gtyp_Setup".x_Set_Calib_Value_Color_Blue THEN
	                "gtyp_Setup".w_Calib_ColorValue_Blue := "IW_SSC_ColorSensor_A1";
	                "gtyp_Setup".x_Set_Calib_Value_Color_Blue := FALSE;
	            ELSIF "gtyp_Setup".x_Set_Calib_Value_Color_Red THEN
	                "gtyp_Setup".w_Calib_ColorValue_Red := "IW_SSC_ColorSensor_A1";
	                "gtyp_Setup".x_Set_Calib_Value_Color_Red := FALSE;
	            ELSIF "gtyp_Setup".x_Set_Calib_Value_Color_White THEN
	                "gtyp_Setup".w_Calib_ColorValue_White := "IW_SSC_ColorSensor_A1";
	                "gtyp_Setup".x_Set_Calib_Value_Color_White := FALSE;
	            END_IF;
	            
	            "gtyp_Setup".w_Threshold_White_Red  := "gtyp_Setup".w_Calib_ColorValue_White + (("gtyp_Setup".w_Calib_ColorValue_Red - "gtyp_Setup".w_Calib_ColorValue_White) / 2);
	            "gtyp_Setup".w_Threshold_Red_Blue   := "gtyp_Setup".w_Calib_ColorValue_Red + (("gtyp_Setup".w_Calib_ColorValue_Blue - "gtyp_Setup".w_Calib_ColorValue_Red) / 2);
	            
	            IF "gtyp_Setup".x_Calculate_Value_Color THEN
	                "gtyp_SSC".w_Threshold_White_Red := "gtyp_Setup".w_Threshold_White_Red;
	                "gtyp_SSC".w_Threshold_Red_Blue := "gtyp_Setup".w_Threshold_Red_Blue;
	                "gtyp_Setup".x_Calculate_Value_Color := FALSE;
	            END_IF;
	            
	            // Statement section ELSE    
	        ELSE
	            ;
	    END_CASE;
	    
	    IF ("gtyp_Setup".i_Color_Sensor_Selection = 1) THEN
	        // Reload Pos Value
	        "gtyp_Setup".w_Actual_ColorValue := "IW_SSC_ColorSensor_A1";
	    END_IF;
	ELSE
	    #lx_Init := TRUE;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "PRG_HBW_Axis_Horizontal"
TITLE = Program Axis horizontal HBW
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
   VAR 
      lx_Init { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lfb_Horizontal_Axis { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Axis";
   END_VAR


BEGIN
	IF #lx_Init THEN
	    
	    // FB Axis horizontal
	    #lfb_Horizontal_Axis(ini_Axis               := 6,
	                         indi_Increment          := "gtyp_HBW".Horizontal_Axis.di_Increment,
	                         inx_Ref_Switch         := "IX_HBW_RefSwitchHorizontalAxis_I1",
	                         inx_Referencing        := "gtyp_HBW".Horizontal_Axis.x_Reference,
	                         inx_Start_Positioning  := "gtyp_HBW".Horizontal_Axis.x_Start_Positioning,
	                         indi_Target_Position   := "gtyp_HBW".Horizontal_Axis.di_Target_Position,
	                         ini_PWM                := "gtyp_HBW".Horizontal_Axis.i_PWM,
	                         inouttyp_Config        := "gtyp_HBW".Horizontal_Axis.Config,
	                         inouttyp_Setup         := "gtyp_SetupAxis");
	    
	    "QX_HBW_M2_HorizontalTowardsRack_Q3"            := #lfb_Horizontal_Axis.outx_Motor_Pos;
	    "QX_HBW_M2_HorizontalTowardsConveyorBelt_Q4"    := #lfb_Horizontal_Axis.outx_Motor_Neg;
	    "QW_HBW_PWM_HorizontalAxis_M2"                  := #lfb_Horizontal_Axis.outi_Motor_PWM;
	    "gtyp_HBW".Horizontal_Axis.di_Actual_Position   := #lfb_Horizontal_Axis.outdi_Actual_Position;
	    "gtyp_HBW".Horizontal_Axis.x_Referenced         := #lfb_Horizontal_Axis.outx_Referenced;
	    "gtyp_HBW".Horizontal_Axis.x_Position_Reached   := #lfb_Horizontal_Axis.outx_Position_Reached;
	ELSE
	    #lx_Init := TRUE;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "PRG_HBW_Axis_Vertical"
TITLE = Program Axis vertical HBW
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
   VAR 
      lx_Init { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lfb_Vertical_Axis { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Axis";
   END_VAR


BEGIN
	IF #lx_Init THEN
	    
	    // FB Axis vertical
	    #lfb_Vertical_Axis( ini_Axis                := 7,
	                        indi_Increment          := "gtyp_HBW".Vertical_Axis.di_Increment,
	                        inx_Ref_Switch          := "IX_HBW_RefSwitchVerticalAxis_I4",
	                        inx_Referencing         := "gtyp_HBW".Vertical_Axis.x_Reference,
	                        inx_Start_Positioning   := "gtyp_HBW".Vertical_Axis.x_Start_Positioning,
	                        indi_Target_Position    := "gtyp_HBW".Vertical_Axis.di_Target_Position,
	                        ini_PWM                 := "gtyp_HBW".Vertical_Axis.i_PWM,
	                        inouttyp_Config         := "gtyp_HBW".Vertical_Axis.Config,
	                        inouttyp_Setup          := "gtyp_SetupAxis");
	    
	    "QX_HBW_M3_VerticalAxisDownward_Q5"           := #lfb_Vertical_Axis.outx_Motor_Pos;
	    "QX_HBW_M3_VerticalAxisUpward_Q6"             := #lfb_Vertical_Axis.outx_Motor_Neg;
	    "QW_HBW_PWM_VerticalAxis_M3"                  := #lfb_Vertical_Axis.outi_Motor_PWM;
	    "gtyp_HBW".Vertical_Axis.di_Actual_Position   := #lfb_Vertical_Axis.outdi_Actual_Position;
	    "gtyp_HBW".Vertical_Axis.x_Referenced         := #lfb_Vertical_Axis.outx_Referenced;
	    "gtyp_HBW".Vertical_Axis.x_Position_Reached   := #lfb_Vertical_Axis.outx_Position_Reached;
	ELSE
	    #lx_Init := TRUE;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "PRG_VGR_Ablauf"
TITLE = Program Ablauf VGR
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
   VAR 
      lx_Init { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Start_TON_Wait { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Start_TON_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lt_TON_Wait { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;
      ldt_MQTT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Date_And_Time;
      li_Return_LDT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      li_Lights { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      li_Lights_old { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      lx_State_activ { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      li_StepCase { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      li_Counter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ldi_Pos_SLD_X { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      ldi_Pos_SLD_Y { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      ldi_Pos_SLD_Z { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      ls_Color { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;
      ls_Target { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;
      lfb_TON_Wait {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      lfb_TON_State {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      lfb_R_Trig_NiO {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
   END_VAR


BEGIN
	IF #lx_Init THEN
	    
	    // Restart after set Positioning
	    IF "gtyp_Setup".x_Set_Pos_Activ OR "gtyp_Setup".x_Color_Sensor_Calibration THEN
	        #li_StepCase := 0;
	    END_IF;
	    
	    // wait time state
	    #lfb_TON_State(IN := NOT #lx_Start_TON_State,
	                    PT := T#2s);
	    
	     IF "gtyp_VGR".x_State_Process THEN
	         #li_Return_LDT := RD_SYS_T(#ldt_MQTT);
	         "gtyp_Interface_Dashboard".Subscribe.State_Order.ldt_ts := DT_TO_LDT(#ldt_MQTT);
	     END_IF;
	     
	    // state of the robot cyclically transmitted to the cloud
	    IF (#lfb_TON_State.Q OR (#li_Lights <> #li_Lights_old)) AND NOT #lx_Start_TON_State THEN
	        #li_Lights_old := #li_Lights;
	        #lx_Start_TON_State := TRUE;
	        #li_Return_LDT := RD_SYS_T(#ldt_MQTT);
	        "gtyp_Interface_Dashboard".Subscribe.State_VGR.ldt_ts       := DT_TO_LDT(#ldt_MQTT);
	        "gtyp_Interface_Dashboard".Subscribe.State_VGR.i_code       := #li_Lights;
	        "gtyp_Interface_Dashboard".Subscribe.State_VGR.s_description:= '';
	        "gtyp_Interface_Dashboard".Subscribe.State_VGR.s_station    := 'vgr';
	        "gtyp_Interface_Dashboard".Subscribe.State_VGR.s_target     := #ls_Target;
	        "gtyp_Interface_Dashboard".Subscribe.State_VGR.x_active     := #lx_State_activ;
	        
	        "gtyp_Interface_Dashboard".Subscribe.PosPanTiltUnit.ldt_ts := DT_TO_LDT(#ldt_MQTT);
	    END_IF;
	    
	    // restart wait time state
	    IF NOT #lfb_TON_State.Q AND #lx_Start_TON_State THEN
	        #lx_Start_TON_State := FALSE;
	    END_IF;
	    
	    // rising edge Workpiece NiO
	    #lfb_R_Trig_NiO(CLK := "gtyp_VGR".x_Workpiece_NiO);
	    
	    IF #lfb_R_Trig_NiO.Q THEN
	        #lx_Start_TON_Wait := FALSE;
	        #lx_State_activ := FALSE;
	        #li_Lights := 4;
	        #ls_Target := '';
	        "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	        "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	        "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	        "gtyp_VGR".x_NFC_Start_First := FALSE;
	        "gtyp_VGR".x_NFC_Start := FALSE;
	        #li_StepCase := 70;
	    END_IF;
	    
	    // FB TON Wait
	    #lfb_TON_Wait(IN := #lx_Start_TON_Wait,
	                    PT := #lt_TON_Wait);
	      
	    // step chain VGR
	    CASE #li_StepCase OF
	            
	        0:  // init
	            #lx_Start_TON_Wait := FALSE;
	            #li_Lights := 1;
	            #lx_State_activ := FALSE;
	            #ls_Target := '';
	            "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	            "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	            "gtyp_VGR".x_HBW_Storage := FALSE;
	            "gtyp_VGR".x_HBW_Outsource := FALSE;
	            "gtyp_VGR".x_NFC_Start_First := FALSE;
	            "gtyp_VGR".x_NFC_Start := FALSE;
	            "gtyp_VGR".x_Ready_For_Outsource := FALSE;
	            "QX_VGR_Compressor_Q7" := FALSE;
	            "QX_VGR_ValveVacuum_Q8" := FALSE;
	            
	            IF NOT "gtyp_Setup".x_Set_Pos_Activ THEN
	                #li_StepCase := 10;
	            END_IF;
	            
	        10: // homing vertical axis
	            #li_Lights := 2;
	            "gtyp_VGR".x_Ready_For_Outsource     := TRUE;
	            "gtyp_VGR".vertical_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                #li_StepCase := 20;
	            END_IF;
	            
	        20: // homed vertical axis
	            IF "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                "gtyp_VGR".vertical_Axis.x_Reference := FALSE;
	                #li_StepCase := 30;
	            END_IF;
	            
	        30: // homing horizontal axis
	            "gtyp_VGR".horizontal_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                #li_StepCase := 40;
	            END_IF;
	            
	        40: // homed horizontal axis
	            IF "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                "gtyp_VGR".horizontal_Axis.x_Reference := FALSE;
	                #li_StepCase := 50;
	            END_IF;
	            
	        50: // homing rotate axis
	            "gtyp_VGR".rotate_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".rotate_Axis.x_Referenced THEN
	                #li_StepCase := 60;
	            END_IF;
	            
	        60: // homed rotate axis
	            IF "gtyp_VGR".rotate_Axis.x_Referenced THEN
	                "gtyp_VGR".rotate_Axis.x_Reference := FALSE;
	                #li_StepCase := 70;
	            END_IF;
	            
	        70: // Deciding which route to take
	            
	            #li_Lights := 1;
	            #lx_State_activ := FALSE;
	            #ls_Target := '';
	            "gtyp_VGR".x_Ready_For_Outsource := TRUE;
	            
	            // Procedure - bad part
	            IF "gtyp_VGR".x_Workpiece_NiO THEN
	                "gtyp_VGR".x_Ready_For_Outsource := FALSE;
	                #li_Lights := 4;
	                #li_StepCase := 1200;
	            // Procedure - pick up finished parts blue
	            ELSIF NOT "IX_SLD_LightBarrierBlue_I7" THEN
	                #ldi_Pos_SLD_X := "gtyp_VGR".di_Pos_SLD_Blue_horizontal;
	                #ldi_Pos_SLD_Y := "gtyp_VGR".di_Pos_SLD_Blue_vertical;
	                #ldi_Pos_SLD_Z := "gtyp_VGR".di_Pos_SLD_Blue_rotate;
	                "gtyp_VGR".x_Ready_For_Outsource := FALSE;
	                #li_StepCase := 100;
	            // Procedure - pick up finished parts red
	            ELSIF NOT "IX_SLD_LightBarrierRed_I6" THEN
	                #ldi_Pos_SLD_X := "gtyp_VGR".di_Pos_SLD_Red_horizontal;
	                #ldi_Pos_SLD_Y := "gtyp_VGR".di_Pos_SLD_Red_vertical;
	                #ldi_Pos_SLD_Z := "gtyp_VGR".di_Pos_SLD_Red_rotate;
	                "gtyp_VGR".x_Ready_For_Outsource := FALSE;
	                #li_StepCase := 100;
	            // Procedure - pick up finished parts white
	            ELSIF NOT "IX_SLD_LightBarrierWhite_I5" THEN
	                #ldi_Pos_SLD_X := "gtyp_VGR".di_Pos_SLD_White_horizontal;
	                #ldi_Pos_SLD_Y := "gtyp_VGR".di_Pos_SLD_White_vertical;
	                #ldi_Pos_SLD_Z := "gtyp_VGR".di_Pos_SLD_White_rotate;
	                "gtyp_VGR".x_Ready_For_Outsource := FALSE;
	                #li_StepCase := 100;
	            // Procedure - outsource to manufacturing
	            ELSIF "gtyp_VGR".x_HBW_Outsource THEN
	                // Order State
	                "gtyp_Interface_Dashboard".Subscribe.State_Order.ldt_ts := DT_TO_LDT(#ldt_MQTT);
	                "gtyp_Interface_Dashboard".Subscribe.State_Order.s_state := 'ORDERED';
	                "gtyp_Interface_Dashboard".Subscribe.State_Order.s_type := "gtyp_VGR".s_HBW_Outsource_Typ;
	                #li_StepCase := 400;
	            // Procedure - store raw parts
	            ELSIF NOT "IX_SSC_LightBarrierStorage_I3" THEN
	                "gtyp_VGR".x_Ready_For_Outsource := FALSE;
	                #li_Lights := 2;
	                "gtyp_VGR".x_HBW_Storage  := TRUE;
	                #li_StepCase                := 600;
	            END_IF;
	            
	        (**************************************************************************************************)
	        (****************************    Procedure - pick up finished parts    ****************************)
	        (**************************************************************************************************)
	        100: // Position of finished part 
	            
	            #li_Lights := 2;
	            "gtyp_VGR".horizontal_Axis.di_Target_Position := #ldi_Pos_SLD_X;
	            "gtyp_VGR".horizontal_Axis.x_Start_Positioning := TRUE;
	            
	            "gtyp_VGR".vertical_Axis.x_Reference := TRUE;
	            
	            "gtyp_VGR".rotate_Axis.di_Target_Position := #ldi_Pos_SLD_Z;
	            "gtyp_VGR".rotate_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= (#ldi_Pos_SLD_X + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= (#ldi_Pos_SLD_X - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".rotate_Axis.di_Actual_Position <= (#ldi_Pos_SLD_Z + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= (#ldi_Pos_SLD_Z - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF NOT "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                #li_StepCase := 110;
	            END_IF;
	            
	        110: // position of finished part reached         
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= (#ldi_Pos_SLD_X + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= (#ldi_Pos_SLD_X - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".rotate_Axis.di_Actual_Position <= (#ldi_Pos_SLD_Z + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= (#ldi_Pos_SLD_Z - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                "gtyp_VGR".vertical_Axis.x_Reference := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= (#ldi_Pos_SLD_X + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= (#ldi_Pos_SLD_X - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached
	                AND "gtyp_VGR".vertical_Axis.x_Referenced
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position <= (#ldi_Pos_SLD_Z + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= (#ldi_Pos_SLD_Z - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 120;
	            END_IF;
	            
	        120: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 130;
	            END_IF;
	            
	        130: // Position vertical finished part
	            "gtyp_VGR".vertical_Axis.di_Target_Position := #ldi_Pos_SLD_Y;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= (#ldi_Pos_SLD_Y + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= (#ldi_Pos_SLD_Y - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 140;
	            END_IF;
	            
	        140: // start compressor
	            "QX_VGR_Compressor_Q7" := TRUE;
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#1000ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 150;
	            END_IF;
	            
	        150: // turn on the vacuum and pick up the part
	            "QX_VGR_ValveVacuum_Q8" := true;
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#1000ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #lx_State_activ := TRUE;
	                #ls_Target := 'dso';
	                "gtyp_VGR".History   := "gtyp_SLD".History;
	                "gtyp_VGR".Workpiece := "gtyp_SLD".Workpiece;
	                "gtyp_SLD".Workpiece.s_id := '0';
	                "gtyp_SLD".Workpiece.s_state := '';
	                "gtyp_SLD".Workpiece.s_type := '';
	                FOR #li_Counter := 1 TO 8 DO
	                    "gtyp_SLD".History[#li_Counter].i_code := 0;
	                    "gtyp_SLD".History[#li_Counter].ldt_ts := DT#1990-01-01-00:00:00;
	                END_FOR;
	                
	                #li_Return_LDT := RD_SYS_T(#ldt_MQTT);
	                "gtyp_VGR".History[8].i_code := 800;
	                "gtyp_VGR".History[8].ldt_ts := DT_TO_LDT(#ldt_MQTT);
	                
	                "gtyp_Interface_Dashboard".Subscribe.State_SLD.x_active := FALSE;
	                
	                #li_StepCase := 160;
	            END_IF;
	            
	        160: // Position vertical preposition NFC
	            "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 170;
	            END_IF;
	            
	        170: // homing horizontal axis
	            "gtyp_VGR".horizontal_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                #li_StepCase := 180;
	            END_IF;
	            
	        180: // homed horizontal axis
	            IF "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                "gtyp_VGR".horizontal_Axis.x_Reference           := FALSE;
	                #li_StepCase := 190;
	            END_IF;
	            
	        190: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 200;
	            END_IF;
	            
	        200: // Position horizontal/rotate NFC
	            
	            "gtyp_VGR".horizontal_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NFC_horizontal;
	            "gtyp_VGR".horizontal_Axis.x_Start_Positioning := TRUE;
	            "gtyp_VGR".rotate_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NFC_rotate;
	            "gtyp_VGR".rotate_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 210;
	            END_IF;
	            
	        210: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 220;
	            END_IF;
	            
	        220: // Position vertical NFC
	            
	            "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NFC_vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 230;
	            END_IF;
	            
	        230: // Start write/read NFC
	            
	            "gtyp_VGR".x_NFC_Start := TRUE;
	            
	            IF "gtyp_VGR".x_NFC_Completed THEN
	                "gtyp_VGR".x_NFC_Start := FALSE;
	                #li_StepCase := 240;
	            END_IF;
	            
	        240: // homing vertical axis
	            
	            "gtyp_VGR".vertical_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                #li_StepCase := 250;
	            END_IF;
	            
	        250: // homed vertical axis
	            IF "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                "gtyp_VGR".vertical_Axis.x_Reference := FALSE;
	                #li_StepCase := 260;
	            END_IF;
	            
	        260: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 270;
	            END_IF;
	            
	        270: // Position horizontal/rotate DSO Output
	            
	            "gtyp_VGR".horizontal_Axis.di_Target_Position := "gtyp_VGR".di_Pos_DSO_horizontal;
	            "gtyp_VGR".horizontal_Axis.x_Start_Positioning := TRUE;
	            
	            "gtyp_VGR".rotate_Axis.di_Target_Position := "gtyp_VGR".di_Pos_DSO_rotate;
	            "gtyp_VGR".rotate_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_DSO_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_DSO_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_DSO_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_DSO_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_DSO_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_DSO_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_DSO_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_DSO_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached
	                AND "IX_SSC_LightBarrierOutsourcing_I4" THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 280;
	            END_IF;
	            
	        280: // Position vertical DSO discard output
	            
	            "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_DSO_Discard_vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_DSO_Discard_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_DSO_Discard_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                "gtyp_VGR".x_State_Process := FALSE;
	                #li_StepCase := 290;
	            END_IF;
	            
	        290: // turn off vacuum
	            "QX_VGR_ValveVacuum_Q8" := FALSE;
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #li_Return_LDT := RD_SYS_T(#ldt_MQTT);
	                // Order State
	                "gtyp_Interface_Dashboard".Subscribe.State_Order.ldt_ts := DT_TO_LDT(#ldt_MQTT);
	                "gtyp_Interface_Dashboard".Subscribe.State_Order.s_state := 'SHIPPED';
	                "gtyp_Interface_Dashboard".Subscribe.State_Order.s_type := "gtyp_VGR".Workpiece.s_type;
	                "gtyp_SSC".Workpiece := "gtyp_VGR".Workpiece;
	                "gtyp_SSC".History   := "gtyp_VGR".History;
	                "gtyp_VGR".Workpiece.s_id := '0';
	                "gtyp_VGR".Workpiece.s_state := '';
	                "gtyp_VGR".Workpiece.s_type := '';
	                FOR #li_Counter := 1 TO 8 DO
	                    "gtyp_VGR".History[#li_Counter].i_code := 0;
	                    "gtyp_VGR".History[#li_Counter].ldt_ts := DT#1990-01-01-00:00:00;
	                END_FOR;
	                
	                "gtyp_Interface_Dashboard".Subscribe.State_DSO.x_active := TRUE;
	                
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 300;
	            END_IF;
	            
	        300: // turn off compressor
	            "QX_VGR_Compressor_Q7" := FALSE;
	            #lx_State_activ := FALSE;
	            #ls_Target := '';
	            #li_StepCase := 310;
	            
	        310: // homing vertical axis
	            "gtyp_VGR".vertical_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                #li_StepCase := 320;
	            END_IF;
	            
	        320: // homed vertical axis
	            IF "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                "gtyp_VGR".vertical_Axis.x_Reference := FALSE;
	                #li_StepCase := 330;
	            END_IF;
	            
	        330: // homing horizontal/rotate axis
	            "gtyp_VGR".horizontal_Axis.x_Reference := TRUE;
	            "gtyp_VGR".rotate_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".horizontal_Axis.x_Referenced AND NOT "gtyp_VGR".rotate_Axis.x_Referenced THEN
	                #li_StepCase := 340;
	            END_IF;
	            
	        340: // homed horizontal/rotate axis
	            IF "gtyp_VGR".horizontal_Axis.x_Referenced AND "gtyp_VGR".rotate_Axis.x_Referenced THEN
	                "gtyp_VGR".horizontal_Axis.x_Reference := FALSE;
	                "gtyp_VGR".rotate_Axis.x_Reference := FALSE;
	                #li_StepCase := 350;
	            END_IF;
	            
	        350: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 70;
	            END_IF;
	            
	        (*******************************************************************************************)
	        (****************************           outsource HBW           ****************************)
	        (*******************************************************************************************)
	        400: // Position rotate HBW and homing vertical/horizontal axis
	            #li_Lights := 2;
	            "gtyp_VGR".rotate_Axis.di_Target_Position := "gtyp_VGR".di_Pos_HBW_rotate;
	            "gtyp_VGR".rotate_Axis.x_Start_Positioning := TRUE;
	            
	            "gtyp_VGR".horizontal_Axis.x_Reference := TRUE;
	            "gtyp_VGR".vertical_Axis.x_Reference := TRUE;
	            
	            IF ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_HBW_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_HBW_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF NOT "gtyp_VGR".horizontal_Axis.x_Referenced AND NOT "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                #li_StepCase := 410;
	            END_IF;
	            
	        410: // Position reached rotate HBW and homed vertical/horizontal axis
	            
	            IF ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_HBW_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_HBW_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                "gtyp_VGR".horizontal_Axis.x_Reference := FALSE;
	            END_IF;
	            IF "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                "gtyp_VGR".vertical_Axis.x_Reference := FALSE;
	            END_IF;
	            IF "gtyp_VGR".horizontal_Axis.x_Referenced
	                AND "gtyp_VGR".vertical_Axis.x_Referenced
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_HBW_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_HBW_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Reference := FALSE;
	                "gtyp_VGR".vertical_Axis.x_Reference := FALSE;
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 420;
	            END_IF;
	            
	        420: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 430;
	            END_IF;
	            
	        430: // Position horizontal HBW 
	            
	            "gtyp_VGR".horizontal_Axis.di_Target_Position := "gtyp_VGR".di_Pos_HBW_horizontal;
	            "gtyp_VGR".horizontal_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_HBW_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_HBW_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 440;
	            END_IF;
	            
	        440: // Container Available start pick up
	            IF "gtyp_HBW".x_HBW_Container_Available THEN
	                #li_StepCase := 450;
	            END_IF;
	            
	        450: // Position vertical Collect HBW
	            "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_HBW_Collect_vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_HBW_Collect_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_HBW_Collect_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 460;
	            END_IF;
	            
	        460: // turn on compressor
	            "QX_VGR_Compressor_Q7" := TRUE;
	            "gtyp_VGR".x_MPO_Req_Discard := TRUE;
	            #li_StepCase := 470;
	            
	        470: // turn on vacuum
	            "QX_VGR_ValveVacuum_Q8" := TRUE;
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 480;
	            END_IF;
	            
	        480: // homing vertical axis
	            
	            "gtyp_VGR".vertical_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                "gtyp_VGR".x_HBW_PickedUp := TRUE;
	                #li_StepCase := 485;
	            END_IF;
	            
	        485: // homed vertical axis
	            IF "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                "gtyp_VGR".vertical_Axis.x_Reference := FALSE;
	                #li_StepCase := 490;
	            END_IF;
	            
	        490: // homing horizontal axis
	            
	            "gtyp_VGR".horizontal_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                #li_StepCase := 495;
	            END_IF;
	            
	        495: // homed horizontal axis
	            IF "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                "gtyp_VGR".horizontal_Axis.x_Reference := FALSE;
	                #li_StepCase := 500;
	            END_IF;
	            
	        500: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_State_activ := TRUE;
	                #ls_Target      := 'mpo';
	                "gtyp_VGR".x_HBW_PickedUp := FALSE;
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 510;
	            END_IF;
	            
	        510: // Position rotate MPO
	            
	            "gtyp_VGR".rotate_Axis.di_Target_Position := "gtyp_VGR".di_Pos_MPO_rotate;
	            "gtyp_VGR".rotate_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_MPO_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_MPO_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 515;
	            END_IF;
	            
	        515: // Position horizontal/pre vertical MPO
	            
	            "gtyp_VGR".horizontal_Axis.di_Target_Position := "gtyp_VGR".di_Pos_MPO_horizontal;
	            "gtyp_VGR".horizontal_Axis.x_Start_Positioning := TRUE;
	            "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_MPO_vertical - "gtyp_VGR".di_Offset_Pos_MPO_vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_MPO_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_MPO_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_MPO_vertical - "gtyp_VGR".di_Offset_Pos_MPO_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_MPO_vertical - "gtyp_VGR".di_Offset_Pos_MPO_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_MPO_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_MPO_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_MPO_vertical - "gtyp_VGR".di_Offset_Pos_MPO_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_MPO_vertical - "gtyp_VGR".di_Offset_Pos_MPO_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 520;
	            END_IF;
	            
	        520: // MPO ready to discard - Position vertical MPO
	            
	            IF "gtyp_MPO".x_Discard_Ready THEN
	                "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_MPO_vertical;
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	                
	                IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_MPO_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                    AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_MPO_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                    AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                    "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                    #li_StepCase := 530;
	                    "gtyp_VGR".x_MPO_Req_Discard := FALSE;
	                END_IF;
	            END_IF;
	            
	        530: // turn off vacuum
	            "QX_VGR_ValveVacuum_Q8" := FALSE;
	            #li_StepCase := 540;
	            
	        540: // turn off compressor
	            "QX_VGR_Compressor_Q7" := FALSE;
	            "gtyp_VGR".x_MPO_Discards := TRUE;
	            // Order State
	            "gtyp_VGR".x_Ready_For_Outsource := FALSE;
	            "gtyp_VGR".x_State_Process       := TRUE;
	            "gtyp_Interface_Dashboard".Subscribe.State_Order.ldt_ts := DT_TO_LDT(#ldt_MQTT);
	            "gtyp_Interface_Dashboard".Subscribe.State_Order.s_state := 'IN_PROCESS';
	            "gtyp_Interface_Dashboard".Subscribe.State_Order.s_type := "gtyp_VGR".Workpiece.s_type;
	            #li_StepCase := 550;
	            
	        550: // Workpiece discard accepted - Position pre vertical MPO
	            
	            IF "gtyp_MPO".x_MPO_Discards_Accepted THEN
	                "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_MPO_vertical - "gtyp_VGR".di_Offset_Pos_MPO_vertical;
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	                
	                IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_MPO_vertical - "gtyp_VGR".di_Offset_Pos_MPO_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                    AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_MPO_vertical - "gtyp_VGR".di_Offset_Pos_MPO_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                    AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                    "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                    "gtyp_VGR".x_MPO_Discards := FALSE;
	                    #li_StepCase := 560;
	                END_IF;
	            END_IF;
	            
	        560: // homing horizontal axis
	            "gtyp_VGR".horizontal_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                #li_StepCase := 570;
	            END_IF;
	            
	        570: // homed horizontal axis
	            IF "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                "gtyp_VGR".horizontal_Axis.x_Reference := FALSE;
	                "gtyp_VGR".x_MPO_Discards := FALSE;
	                #li_StepCase := 580;
	            END_IF;
	            
	        580: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                "gtyp_VGR".Workpiece.s_id := '0';
	                "gtyp_VGR".Workpiece.s_state := '';
	                "gtyp_VGR".Workpiece.s_type := '';
	                FOR #li_Counter := 1 TO 8 DO
	                    "gtyp_VGR".History[#li_Counter].i_code := 0;
	                    "gtyp_VGR".History[#li_Counter].ldt_ts := DT#1990-01-01-00:00:00;
	                END_FOR;
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 0;
	            END_IF;
	            
	        (*******************************************************************************************)
	        (**************************      Procedure - store raw parts      **************************)
	        (*******************************************************************************************)
	            
	        600:// approach pick-up position dsi with vertical, horizontal, rotate axis
	            "gtyp_VGR".horizontal_Axis.di_Target_Position := "gtyp_VGR".di_Pos_DSI_horizontal;
	            "gtyp_VGR".horizontal_Axis.x_Start_Positioning := TRUE;
	            "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_DSI_Collect_vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            "gtyp_VGR".rotate_Axis.di_Target_Position := "gtyp_VGR".di_Pos_DSI_rotate;
	            "gtyp_VGR".rotate_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_DSI_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_DSI_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_DSI_Collect_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_DSI_Collect_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_DSI_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_DSI_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_DSI_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_DSI_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_DSI_Collect_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_DSI_Collect_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_DSI_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_DSI_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 610;
	            END_IF;
	            
	        610:// set status 100 raw goods delivered
	            #li_Return_LDT := RD_SYS_T(#ldt_MQTT);
	            "gtyp_VGR".Workpiece.s_state := 'RAW';
	            "gtyp_VGR".History[1].ldt_ts := DT_TO_LDT(#ldt_MQTT);
	            "gtyp_VGR".History[1].i_code := 100;
	            #li_StepCase := 620;
	            
	        620:// wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 630;
	            END_IF;
	            
	        630:// turn on compressor and wait
	            "QX_VGR_Compressor_Q7" := TRUE;
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 640;
	            END_IF;
	            
	        640:// turn on vacuum 
	            "QX_VGR_ValveVacuum_Q8" := true;
	            
	            #li_StepCase := 650;
	            
	        650:// Position vertical NFC
	            #lx_State_activ := TRUE;
	            #ls_Target      := 'hbw';
	            
	            "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 660;
	            END_IF;
	            
	        660: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 670;
	            END_IF;
	            
	        670: // Position horizontal/rotate NFC
	            
	            "gtyp_VGR".horizontal_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NFC_horizontal;
	            "gtyp_VGR".horizontal_Axis.x_Start_Positioning := TRUE;
	            "gtyp_VGR".rotate_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NFC_rotate;
	            "gtyp_VGR".rotate_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 680;
	            END_IF;
	            
	        680: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 690;
	            END_IF;
	            
	        690: // Position vertical NFC
	            
	            "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NFC_vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 700;
	            END_IF;
	            
	        700: // Start delete/write/read NFC 
	            "gtyp_VGR".x_NFC_Start_First := TRUE;
	            
	            IF "gtyp_VGR".x_NFC_Completed THEN
	                "gtyp_VGR".x_NFC_Start_First := FALSE;
	                #li_StepCase := 710;
	            END_IF;
	            
	        710: // Position vertical pre NFC
	            
	            "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 720;
	            END_IF;
	            
	        720: // Position horizontal/rotate Color
	            
	            "gtyp_VGR".horizontal_Axis.di_Target_Position := "gtyp_VGR".di_Pos_Color_horizontal;
	            "gtyp_VGR".horizontal_Axis.x_Start_Positioning := TRUE;
	            "gtyp_VGR".rotate_Axis.di_Target_Position := "gtyp_VGR".di_Pos_Color_rotate;
	            "gtyp_VGR".rotate_Axis.x_Start_Positioning := TRUE;
	                
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_Color_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_Color_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_Color_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_Color_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_Color_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_Color_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_Color_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_Color_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 730;
	            END_IF;
	            
	        730: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 740;
	            END_IF;
	            
	        740: // Position vertical Color
	            "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_Color_vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	                
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_Color_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_Color_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 750;
	            END_IF;
	            
	        750: // evaluate color workpiece
	            #ls_Color := '';
	            
	            IF "IW_SSC_ColorSensor_A1" >= "gtyp_SSC".w_Threshold_Red_Blue THEN
	 //               IF "IW_SSC_ColorSensor" > 16000 AND "IW_SSC_ColorSensor" < 17500 THEN
	                #ls_Color := 'BLUE';
	            ELSIF "IW_SSC_ColorSensor_A1" <= "gtyp_SSC".w_Threshold_White_Red THEN
	//            ELSIF "IW_SSC_ColorSensor" > 5000 AND "IW_SSC_ColorSensor" < 11000 THEN
	                #ls_Color := 'WHITE';
	            ELSIF "IW_SSC_ColorSensor_A1" > "gtyp_SSC".w_Threshold_White_Red AND "IW_SSC_ColorSensor_A1" < "gtyp_SSC".w_Threshold_Red_Blue THEN
	//            ELSIF "IW_SSC_ColorSensor" > 11000 AND "IW_SSC_ColorSensor" < 16000 THEN
	                #ls_Color := 'RED';
	            END_IF;
	            
	            #li_Return_LDT := RD_SYS_T(#ldt_MQTT);
	            "gtyp_VGR".History[2].ldt_ts := DT_TO_LDT(#ldt_MQTT);
	            "gtyp_VGR".History[2].i_code := 200;
	            "gtyp_VGR".Workpiece.s_type  := #ls_Color;
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 760;
	            END_IF;
	            
	        760: // Position vertical pre NFC
	            "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	                
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 770;
	            END_IF;
	            
	        770: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 780;
	            END_IF;
	            
	        780: // Position horizontal/rotate NFC
	            
	            "gtyp_VGR".horizontal_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NFC_horizontal;
	            "gtyp_VGR".horizontal_Axis.x_Start_Positioning := TRUE;
	            "gtyp_VGR".rotate_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NFC_rotate;
	            "gtyp_VGR".rotate_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 790;
	            END_IF;
	            
	        790: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 800;
	            END_IF;
	            
	        800: // Position vertical NFC
	            
	            "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NFC_vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 810;
	            END_IF;
	            
	        810: // Start write/read NFC Color
	            
	            "gtyp_VGR".x_NFC_Start := TRUE;
	            
	            IF "gtyp_VGR".x_NFC_Completed THEN
	                "gtyp_VGR".x_NFC_Start := FALSE;
	                #li_StepCase := 820;
	            END_IF;
	            
	        820: // Position vertical pre NFC
	            
	            "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 830;
	            END_IF;
	            
	        830: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 840;
	            END_IF;
	            
	        840: // Position rotate HBW and homing horizontal/vertical axis
	            "gtyp_VGR".rotate_Axis.di_Target_Position := "gtyp_VGR".di_Pos_HBW_rotate;
	            "gtyp_VGR".rotate_Axis.x_Start_Positioning := TRUE;
	            
	            "gtyp_VGR".horizontal_Axis.x_Reference := TRUE;
	            "gtyp_VGR".vertical_Axis.x_Reference := TRUE;
	            
	            IF ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_HBW_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_HBW_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF NOT "gtyp_VGR".horizontal_Axis.x_Referenced AND NOT "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                #li_StepCase := 850;
	            END_IF;
	            
	        850: // Position rotate HBW reached and homed horizontal/vertical axis
	            
	            IF ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_HBW_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_HBW_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                "gtyp_VGR".horizontal_Axis.x_Reference := FALSE;
	            END_IF;
	            IF "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                "gtyp_VGR".vertical_Axis.x_Reference := FALSE;
	            END_IF;
	            IF "gtyp_VGR".horizontal_Axis.x_Referenced
	                AND "gtyp_VGR".vertical_Axis.x_Referenced
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_HBW_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_HBW_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Reference := FALSE;
	                "gtyp_VGR".vertical_Axis.x_Reference := FALSE;
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 860;
	            END_IF;
	            
	        860: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 870;
	            END_IF;
	            
	        870: // Position horizontal HBW
	            
	            "gtyp_VGR".horizontal_Axis.di_Target_Position := "gtyp_VGR".di_Pos_HBW_horizontal;
	            "gtyp_VGR".horizontal_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_HBW_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_HBW_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 880;
	            END_IF;
	            
	        880: // container available start drop down
	            IF "gtyp_HBW".x_HBW_Container_Available THEN
	                #li_StepCase := 890;
	            END_IF;
	            
	        890: // Position vertical discard HBW
	            "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_HBW_Discard_vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_HBW_Discard_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_HBW_Discard_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 900;
	            END_IF;
	            
	        900: // turn off vacuum
	            "QX_VGR_ValveVacuum_Q8" := FALSE;
	            #li_StepCase := 910;
	            
	        910: // turn off compressor
	            "QX_VGR_Compressor_Q7" := FALSE;
	            "gtyp_VGR".x_HBW_Discards := TRUE;
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q AND "gtyp_HBW".x_HBW_Discards_Accepted THEN
	                #lx_State_activ := FALSE;
	                #ls_Target := '';
	                "gtyp_VGR".x_HBW_Discards   := FALSE;
	                "gtyp_VGR".x_HBW_Storage  := FALSE;
	                #lx_Start_TON_Wait                   := FALSE;
	                #li_StepCase                := 920;
	            END_IF;
	            
	        920: // homing vertical axis
	            "gtyp_VGR".vertical_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                #li_StepCase := 930;
	            END_IF;
	            
	        930: // homed vertical axis
	            IF "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                "gtyp_VGR".vertical_Axis.x_Reference := FALSE;
	                #li_StepCase := 940;
	            END_IF;
	            
	        940: // homing horizontal axis
	            "gtyp_VGR".horizontal_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                #li_StepCase := 950;
	            END_IF;
	            
	        950: // homed horizontal axis
	            IF "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                "gtyp_VGR".horizontal_Axis.x_Reference := FALSE;
	                #li_StepCase := 960;
	            END_IF;
	            
	        960: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q AND "gtyp_HBW".x_HBW_Discards_Accepted THEN
	                "gtyp_VGR".x_HBW_Discards  := FALSE;
	                #lx_Start_TON_Wait               := FALSE;
	                "gtyp_VGR".Workpiece.s_id       := '';
	                "gtyp_VGR".Workpiece.s_state    := '';
	                "gtyp_VGR".Workpiece.s_type     := '';
	                FOR #li_Counter := 1 TO 8 DO
	                    // Statement section FOR
	                    "gtyp_VGR".History[#li_Counter].i_code := 0;
	                    "gtyp_VGR".History[#li_Counter].ldt_ts := DT#1990-01-01-00:00:00;
	                END_FOR;
	                #li_StepCase := 0;
	            END_IF;
	            
	        1200:// homing vertical axis
	            "gtyp_VGR".Workpiece.s_id := '0';
	            "gtyp_VGR".Workpiece.s_state := '';
	            "gtyp_VGR".Workpiece.s_type := '';
	            FOR #li_Counter := 1 TO 8 DO
	                "gtyp_VGR".History[#li_Counter].i_code := 0;
	                "gtyp_VGR".History[#li_Counter].ldt_ts := DT#1990-01-01-00:00:00;
	            END_FOR;
	            
	            IF "gtyp_HBW".x_HBW_Container_Available THEN
	                "gtyp_VGR".x_HBW_Discards := TRUE;
	            END_IF;
	            
	            IF "gtyp_HBW".x_HBW_Discards_Accepted OR "gtyp_HBW".x_HBW_PickedUp_Accepted THEN
	                "gtyp_VGR".x_HBW_Discards := FALSE;
	                "gtyp_VGR".x_HBW_PickedUp := FALSE;
	                "gtyp_HBW".x_HBW_Discards_Accepted := FALSE;
	                "gtyp_HBW".x_HBW_PickedUp_Accepted := FALSE;
	            END_IF;
	            
	            #li_Lights := 2;
	            "gtyp_VGR".vertical_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                #li_StepCase := 1210;
	            END_IF;
	            
	        1210: // homed vertical axis
	            IF "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                "gtyp_VGR".vertical_Axis.x_Reference := FALSE;
	                #li_StepCase := 1220;
	            END_IF;
	            
	        1220: // homing horizontal axis
	            "gtyp_VGR".horizontal_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                #li_StepCase := 1230;
	            END_IF;
	            
	        1230: // homed horizontal axis
	            IF "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                "gtyp_VGR".horizontal_Axis.x_Reference := FALSE;
	                #li_StepCase := 1240;
	            END_IF;
	            
	        1240: // homing rotate axis
	            "gtyp_VGR".rotate_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".rotate_Axis.x_Referenced THEN
	                #li_StepCase := 1250;
	            END_IF;
	            
	        1250: // homed horizontal axis
	            IF "gtyp_VGR".rotate_Axis.x_Referenced THEN
	                "gtyp_VGR".rotate_Axis.x_Reference := FALSE;
	                #li_StepCase := 1260;
	            END_IF;
	            
	        1260: // Position vertical/horizontal/rotate NiO
	            "gtyp_VGR".horizontal_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NiO_horizontal;
	            "gtyp_VGR".horizontal_Axis.x_Start_Positioning := TRUE;
	            "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NiO_vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            "gtyp_VGR".rotate_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NiO_rotate;
	            "gtyp_VGR".rotate_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NiO_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NiO_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NiO_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NiO_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NiO_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NiO_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NiO_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NiO_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NiO_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NiO_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NiO_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NiO_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 1270;
	            END_IF;
	            
	        1270: // turn off vacuum
	            "QX_VGR_ValveVacuum_Q8" := FALSE;
	            #li_StepCase := 1280;
	            
	        1280: // turn off compressor
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#1000ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                "QX_VGR_Compressor_Q7"  := FALSE;
	                #lx_Start_TON_Wait               := FALSE;
	                "gtyp_VGR".x_Workpiece_NiO := FALSE;
	                "gtyp_VGR".x_HBW_Discards := FALSE;
	                #li_Lights := 1;
	                #li_StepCase            := 0;
	            END_IF;
	    // Statement section ELSE       
	    ELSE  
	            ;
	    END_CASE;
	 
	ELSE
	    "gtyp_VGR".Workpiece.s_id := '';
	    "gtyp_VGR".Workpiece.s_state := '';
	    "gtyp_VGR".Workpiece.s_type := '';
	    // Order State
	    "gtyp_VGR".x_State_Process := FALSE;
	    "gtyp_Interface_Dashboard".Subscribe.State_Order.ldt_ts := DT_TO_LDT(#ldt_MQTT);
	    "gtyp_Interface_Dashboard".Subscribe.State_Order.s_state := 'WAITING_FOR_ORDER';
	    "gtyp_Interface_Dashboard".Subscribe.State_Order.s_type := '';
	    FOR #li_Counter := 1 TO 8 DO
	        "gtyp_VGR".History[#li_Counter].i_code := 0;
	        "gtyp_VGR".History[#li_Counter].ldt_ts := DT#1990-01-01-00:00:00;
	    END_FOR;
	    
	    #li_Lights := 1;
	    #lx_Init := TRUE;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "PRG_VGR_Set_Positioning"
TITLE = Program Set Positioning VGR
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
   VAR 
      lx_Init { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Start_TON_Wait { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Start_Positioning_m { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Start_TON_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lt_TON_Wait { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;
      ldt_MQTT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Date_And_Time;
      li_Return_LDT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      li_Lights { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      li_Lights_old { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      lx_State_activ { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      li_StepCase { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      li_Counter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ldi_Pos_SLD_X { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      ldi_Pos_SLD_Y { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      ldi_Pos_SLD_Z { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      ldi_Pos_Horizontal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      ldi_Pos_Vertical { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      ldi_Pos_Rotate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      ldi_Offset_Vertical { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      ls_Color { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;
      ls_Target { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;
      lfb_TON_Wait {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      lfb_TON_State {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      lfb_R_Trig_Deaktivate {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      lfb_R_Trig_NiO {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
   END_VAR


BEGIN
	IF #lx_Init THEN
	    
	    // FB TON Wait
	    #lfb_TON_Wait(IN := #lx_Start_TON_Wait,
	                  PT := #lt_TON_Wait);
	    
	    #lfb_R_Trig_Deaktivate(CLK := NOT "gtyp_Setup".x_Set_Pos_Activ
	                           OR NOT (("gtyp_Setup".i_Pos_Selection > 40)
	                           AND ("gtyp_Setup".i_Pos_Selection < 61)));
	    // Deaktivate step 150   
	    IF #lfb_R_Trig_Deaktivate.Q THEN
	        "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	        "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	        "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	        "gtyp_VGR".horizontal_Axis.x_Reference := FALSE;
	        "gtyp_VGR".vertical_Axis.x_Reference := FALSE;
	        "gtyp_VGR".rotate_Axis.x_Reference := FALSE;
	        "gtyp_Setup".x_Start_Positioning := FALSE;
	        "gtyp_Setup".x_Final_Positioning := FALSE;
	        "gtyp_Setup".x_Home_Positioning := FALSE;
	        "gtyp_Setup".x_Start_Offset := FALSE;
	        IF (#li_StepCase > 10) THEN
	            #li_StepCase := 150;
	        END_IF;
	    END_IF;
	    
	    // step chain HBW
	    CASE #li_StepCase OF
	            
	        0:  // init
	            #lx_Start_TON_Wait := FALSE;
	            #li_StepCase := 10;
	            
	        10:  // Set Positioning activ?
	            IF "gtyp_Setup".x_Set_Pos_Activ
	                AND (("gtyp_Setup".i_Pos_Selection > 40)
	                AND ("gtyp_Setup".i_Pos_Selection < 61)) THEN
	                // Deciding which Position
	                // Position - Color 
	                IF "gtyp_Setup".i_Pos_Selection = 41 THEN
	                    #ldi_Pos_Horizontal := "gtyp_VGR".di_Pos_Color_horizontal;
	                    #ldi_Pos_Vertical := "gtyp_VGR".di_Pos_Color_vertical;
	                    #ldi_Pos_Rotate := "gtyp_VGR".di_Pos_Color_rotate;
	                    #ldi_Offset_Vertical := "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical;
	                    // Position - DSI Collect
	                ELSIF "gtyp_Setup".i_Pos_Selection = 42 THEN
	                    #ldi_Pos_Horizontal := "gtyp_VGR".di_Pos_DSI_horizontal;
	                    #ldi_Pos_Vertical := "gtyp_VGR".di_Pos_DSI_Collect_vertical;
	                    #ldi_Pos_Rotate := "gtyp_VGR".di_Pos_DSI_rotate;
	                    #ldi_Offset_Vertical := "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical;
	                    // Position - DSI Discard 
	                ELSIF "gtyp_Setup".i_Pos_Selection = 43 THEN
	                    #ldi_Pos_Horizontal := "gtyp_VGR".di_Pos_DSI_horizontal;
	                    #ldi_Pos_Vertical := "gtyp_VGR".di_Pos_DSI_Discard_vertical;
	                    #ldi_Pos_Rotate := "gtyp_VGR".di_Pos_DSI_rotate;
	                    #ldi_Offset_Vertical := "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical;
	                    // Position - DSO Collect 
	                ELSIF "gtyp_Setup".i_Pos_Selection = 44 THEN
	                    #ldi_Pos_Horizontal := "gtyp_VGR".di_Pos_DSO_horizontal;
	                    #ldi_Pos_Vertical := "gtyp_VGR".di_Pos_DSO_Collect_vertical;
	                    #ldi_Pos_Rotate := "gtyp_VGR".di_Pos_DSO_rotate;
	                    #ldi_Offset_Vertical := "gtyp_VGR".di_Offset_Pos_DSO_vertical;
	                    // Position - DSO Discard 
	                ELSIF "gtyp_Setup".i_Pos_Selection = 45 THEN
	                    #ldi_Pos_Horizontal := "gtyp_VGR".di_Pos_DSO_horizontal;
	                    #ldi_Pos_Vertical := "gtyp_VGR".di_Pos_DSO_Discard_vertical;
	                    #ldi_Pos_Rotate := "gtyp_VGR".di_Pos_DSO_rotate;
	                    #ldi_Offset_Vertical := "gtyp_VGR".di_Offset_Pos_DSO_vertical;
	                    // Position - HBW Collect 
	                ELSIF "gtyp_Setup".i_Pos_Selection = 46 THEN
	                    #ldi_Pos_Horizontal := "gtyp_VGR".di_Pos_HBW_horizontal;
	                    #ldi_Pos_Vertical := "gtyp_VGR".di_Pos_HBW_Collect_vertical;
	                    #ldi_Pos_Rotate := "gtyp_VGR".di_Pos_HBW_rotate;
	                    #ldi_Offset_Vertical := "gtyp_VGR".di_Offset_Pos_HBW_vertical;
	                    // Position - HBW Discard 
	                ELSIF "gtyp_Setup".i_Pos_Selection = 47 THEN
	                    #ldi_Pos_Horizontal := "gtyp_VGR".di_Pos_HBW_horizontal;
	                    #ldi_Pos_Vertical := "gtyp_VGR".di_Pos_HBW_Discard_vertical;
	                    #ldi_Pos_Rotate := "gtyp_VGR".di_Pos_HBW_rotate;
	                    #ldi_Offset_Vertical := "gtyp_VGR".di_Offset_Pos_HBW_vertical;
	                    // Position - MPO 
	                ELSIF "gtyp_Setup".i_Pos_Selection = 48 THEN
	                    #ldi_Pos_Horizontal := "gtyp_VGR".di_Pos_MPO_horizontal;
	                    #ldi_Pos_Vertical := "gtyp_VGR".di_Pos_MPO_vertical;
	                    #ldi_Pos_Rotate := "gtyp_VGR".di_Pos_MPO_rotate;
	                    #ldi_Offset_Vertical := "gtyp_VGR".di_Offset_Pos_MPO_vertical;
	                    // Position - NFC 
	                ELSIF "gtyp_Setup".i_Pos_Selection = 49 THEN
	                    #ldi_Pos_Horizontal := "gtyp_VGR".di_Pos_NFC_horizontal;
	                    #ldi_Pos_Vertical := "gtyp_VGR".di_Pos_NFC_vertical;
	                    #ldi_Pos_Rotate := "gtyp_VGR".di_Pos_NFC_rotate;
	                    #ldi_Offset_Vertical := "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical;
	                    // Position - NiO 
	                ELSIF "gtyp_Setup".i_Pos_Selection = 50 THEN
	                    #ldi_Pos_Horizontal := "gtyp_VGR".di_Pos_NiO_horizontal;
	                    #ldi_Pos_Vertical := "gtyp_VGR".di_Pos_NiO_vertical;
	                    #ldi_Pos_Rotate := "gtyp_VGR".di_Pos_NiO_rotate;
	                    // Position - SLD Blue 
	                ELSIF "gtyp_Setup".i_Pos_Selection = 51 THEN
	                    #ldi_Pos_Horizontal := "gtyp_VGR".di_Pos_SLD_Blue_horizontal;
	                    #ldi_Pos_Vertical := "gtyp_VGR".di_Pos_SLD_Blue_vertical;
	                    #ldi_Pos_Rotate := "gtyp_VGR".di_Pos_SLD_Blue_rotate;
	                    // Position - SLD Red 
	                ELSIF "gtyp_Setup".i_Pos_Selection = 52 THEN
	                    #ldi_Pos_Horizontal := "gtyp_VGR".di_Pos_SLD_Red_horizontal;
	                    #ldi_Pos_Vertical := "gtyp_VGR".di_Pos_SLD_Red_vertical;
	                    #ldi_Pos_Rotate := "gtyp_VGR".di_Pos_SLD_Red_rotate;
	                    // Position - SLD White 
	                ELSIF "gtyp_Setup".i_Pos_Selection = 53 THEN
	                    #ldi_Pos_Horizontal := "gtyp_VGR".di_Pos_SLD_White_horizontal;
	                    #ldi_Pos_Vertical := "gtyp_VGR".di_Pos_SLD_White_vertical;
	                    #ldi_Pos_Rotate := "gtyp_VGR".di_Pos_SLD_White_rotate;
	                END_IF;
	                
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	                "gtyp_VGR".horizontal_Axis.x_Reference := FALSE;
	                "gtyp_VGR".vertical_Axis.x_Reference := FALSE;
	                "gtyp_VGR".rotate_Axis.x_Reference := FALSE;
	                "gtyp_Setup".x_Start_Positioning := FALSE;
	                "gtyp_Setup".x_Final_Positioning := FALSE;
	                "gtyp_Setup".x_Home_Positioning := FALSE;
	                "gtyp_Setup".x_Start_Offset := FALSE;
	                #li_StepCase := 20;
	            END_IF;
	            
	        20: // homing vertical axis
	            "gtyp_VGR".vertical_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                #li_StepCase := 30;
	            END_IF;
	        
	        30: // homed vertical axis
	            IF "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                "gtyp_VGR".vertical_Axis.x_Reference := FALSE;
	                #li_StepCase := 40;
	            END_IF;
	                
	        40: // homing horizontal axis
	            "gtyp_VGR".horizontal_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                #li_StepCase := 50;
	            END_IF;
	                
	        50: // homed horizontal axis
	            IF "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                "gtyp_VGR".horizontal_Axis.x_Reference := FALSE;
	                #li_StepCase := 60;
	            END_IF;
	                
	        60: // homing rotate axis
	            "gtyp_VGR".rotate_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".rotate_Axis.x_Referenced THEN
	                #li_StepCase := 70;
	            END_IF;
	                
	        70: // homed rotate axis
	            IF "gtyp_VGR".rotate_Axis.x_Referenced THEN
	                "gtyp_VGR".rotate_Axis.x_Reference := FALSE;
	                #li_StepCase := 80;
	            END_IF;
	            
	        80:  // Start Positioning Step next
	            IF "gtyp_Setup".x_Start_Positioning OR #lx_Start_Positioning_m THEN
	                #lx_Start_Positioning_m := FALSE;
	                #li_StepCase := 90;
	            END_IF;
	            
	        90: // Position rotate Axis
	            "gtyp_VGR".rotate_Axis.di_Target_Position   := #ldi_Pos_Rotate;
	            "gtyp_VGR".rotate_Axis.x_Start_Positioning  := TRUE;
	                
	            IF ("gtyp_VGR".rotate_Axis.di_Actual_Position <= (#ldi_Pos_Rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= (#ldi_Pos_Rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 100;
	            END_IF;
	            
	        100: // Position horizontal Axis
	            "gtyp_VGR".horizontal_Axis.di_Target_Position := #ldi_Pos_Horizontal;
	            "gtyp_VGR".horizontal_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= (#ldi_Pos_Horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= (#ldi_Pos_Horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 110;
	            END_IF;
	            
	        110: // Position vertical Axis + Offset
	            "gtyp_VGR".vertical_Axis.di_Target_Position := #ldi_Pos_Vertical - #ldi_Offset_Vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= (#ldi_Pos_Vertical - #ldi_Offset_Vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= (#ldi_Pos_Vertical - #ldi_Offset_Vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                "gtyp_Setup".x_Start_Positioning := FALSE;
	                #li_StepCase := 120;
	            END_IF;
	            
	        120: // Deciding which doing
	            
	            // Start new Positioning
	            IF "gtyp_Setup".x_Start_Positioning OR "gtyp_Setup".x_Home_Positioning THEN
	                #lx_Start_Positioning_m := TRUE;
	                #li_StepCase := 10;
	                // Start Final Positioning
	            ELSIF "gtyp_Setup".x_Final_Positioning THEN
	                #li_StepCase := 130;
	                // Deaktivate Set Positioning
	            ELSIF #lfb_R_Trig_Deaktivate.Q THEN
	                "gtyp_Setup".x_Home_Positioning := FALSE;
	                #li_StepCase := 150;
	            END_IF;
	            
	        130: // Position vertical Axis
	            "gtyp_VGR".vertical_Axis.di_Target_Position := #ldi_Pos_Vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= (#ldi_Pos_Vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= (#ldi_Pos_Vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                "gtyp_Setup".x_Start_Positioning := FALSE;
	                #li_StepCase := 140;
	            END_IF;
	            
	        140: // Deciding which doing
	            
	            // Start new Positioning
	            IF "gtyp_Setup".x_Start_Positioning OR "gtyp_Setup".x_Home_Positioning THEN
	                #li_StepCase := 10;
	                // Start Final Positioning
	            ELSIF "gtyp_Setup".x_Final_Positioning THEN
	                #li_StepCase := 10;
	                // Deaktivate Set Positioning
	            ELSIF #lfb_R_Trig_Deaktivate.Q THEN
	                "gtyp_Setup".x_Home_Positioning := FALSE;
	                #li_StepCase := 150;
	            END_IF;
	            
	        150: // homing vertical axis
	            "gtyp_VGR".vertical_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                #li_StepCase := 160;
	            END_IF;
	            
	        160: // homed vertical axis
	            IF "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                "gtyp_VGR".vertical_Axis.x_Reference := FALSE;
	                #li_StepCase := 170;
	            END_IF;
	            
	        170: // homing horizontal axis
	            "gtyp_VGR".horizontal_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                #li_StepCase := 180;
	            END_IF;
	            
	        180: // homed horizontal axis
	            IF "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                "gtyp_VGR".horizontal_Axis.x_Reference := FALSE;
	                #li_StepCase := 0;
	            END_IF;
	            
	            // Statement section ELSE    
	        ELSE
	            ;
	    END_CASE;
	    
	    IF (("gtyp_Setup".i_Pos_Selection > 40)
	        AND ("gtyp_Setup".i_Pos_Selection < 61)) THEN
	        // Reload Pos Value
	        "gtyp_Setup".di_Pos_Horizontal := #ldi_Pos_Horizontal;
	        "gtyp_Setup".di_Pos_Vertical := #ldi_Pos_Vertical;
	        "gtyp_Setup".di_Pos_Rotate := #ldi_Pos_Rotate;
	    END_IF;
	ELSE
	    #lx_Init := TRUE;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "PRG_SSC_Set_Positioning"
TITLE = Program Set Positioning SSC
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
   VAR 
      lx_Init { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Start_TON_Wait { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Start_Positioning_m { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lt_TON_Wait { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;
      li_StepCase { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ldi_Pos_Horizontal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      ldi_Pos_Vertical { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      lfb_R_Trig_Deaktivate {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      lfb_TON_Wait {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
   END_VAR


BEGIN
	IF #lx_Init THEN
	    
	    // FB TON Wait
	    #lfb_TON_Wait(IN := #lx_Start_TON_Wait,
	                  PT := #lt_TON_Wait);
	    
	    #lfb_R_Trig_Deaktivate(CLK:= NOT "gtyp_Setup".x_Set_Pos_Activ
	                           OR NOT (("gtyp_Setup".i_Pos_Selection > 0)
	                           AND ("gtyp_Setup".i_Pos_Selection < 21)));
	    // Deaktivate step 10   
	    IF #lfb_R_Trig_Deaktivate.Q THEN
	        "gtyp_SSC".Horizontal_Axis.x_Start_Positioning := FALSE;
	        "gtyp_SSC".Vertical_Axis.x_Start_Positioning := FALSE;
	        "gtyp_SSC".Horizontal_Axis.x_Reference := FALSE;
	        "gtyp_SSC".Vertical_Axis.x_Reference := FALSE;
	        "gtyp_Setup".x_Start_Positioning := FALSE;
	        "gtyp_Setup".x_Final_Positioning := FALSE;
	        "gtyp_Setup".x_Home_Positioning := FALSE;
	        "gtyp_Setup".x_Start_Offset := FALSE;
	        #lx_Start_Positioning_m := FALSE;
	        IF (#li_StepCase > 10) THEN
	            #li_StepCase            := 70;
	        END_IF;
	    END_IF;
	    
	    // step chain HBW
	    CASE #li_StepCase OF
	            
	        0:  // init
	            #lx_Start_TON_Wait := FALSE;
	            #li_StepCase := 10;
	            
	        10:  // Set Positioning activ?
	            IF "gtyp_Setup".x_Set_Pos_Activ
	                AND (("gtyp_Setup".i_Pos_Selection > 0)
	                AND ("gtyp_Setup".i_Pos_Selection < 21)) THEN
	                
	                // Deciding which Position
	                // Position - Centre
	                IF "gtyp_Setup".i_Pos_Selection = 1 THEN
	                    #ldi_Pos_Horizontal := "gtyp_SSC".di_Pos_Centre_Horizontal;
	                    #ldi_Pos_Vertical := "gtyp_SSC".di_Pos_Centre_Vertical;
	                    // Position - HBW 
	                ELSIF "gtyp_Setup".i_Pos_Selection = 2 THEN
	                    #ldi_Pos_Horizontal := "gtyp_SSC".di_Pos_HBW_Horizontal;
	                    #ldi_Pos_Vertical := "gtyp_SSC".di_Pos_HBW_Vertical;
	                END_IF;
	                
	                "gtyp_SSC".Horizontal_Axis.x_Start_Positioning := FALSE;
	                "gtyp_SSC".Vertical_Axis.x_Start_Positioning := FALSE;
	                "gtyp_SSC".Horizontal_Axis.x_Reference := FALSE;
	                "gtyp_SSC".Vertical_Axis.x_Reference := FALSE;
	                "gtyp_Setup".x_Start_Positioning := FALSE;
	                "gtyp_Setup".x_Final_Positioning := FALSE;
	                "gtyp_Setup".x_Home_Positioning  := FALSE;
	                "gtyp_Setup".x_Start_Offset := FALSE;
	                #li_StepCase := 20;
	            END_IF;
	            
	        20: //homing vertical/horizontal axis
	            
	            "gtyp_SSC".Horizontal_Axis.x_Reference := TRUE;
	            "gtyp_SSC".Vertical_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_SSC".Horizontal_Axis.x_Referenced AND NOT "gtyp_SSC".Vertical_Axis.x_Referenced THEN
	                #li_StepCase := 30;
	            END_IF;
	            
	        30: // homed vertical/horizontal axis
	            IF "gtyp_SSC".Horizontal_Axis.x_Referenced THEN
	                "gtyp_SSC".Horizontal_Axis.x_Reference := FALSE;
	            END_IF;
	            IF "gtyp_SSC".Vertical_Axis.x_Referenced THEN
	                "gtyp_SSC".Vertical_Axis.x_Reference := FALSE;
	            END_IF;
	            
	            IF "gtyp_SSC".Horizontal_Axis.x_Referenced AND "gtyp_SSC".Vertical_Axis.x_Referenced THEN
	                "gtyp_SSC".Horizontal_Axis.x_Reference := FALSE;
	                "gtyp_SSC".Vertical_Axis.x_Reference := FALSE;
	                #li_StepCase := 40;
	            END_IF;
	            
	        40:  // Start Positioning Step next
	            IF "gtyp_Setup".x_Start_Positioning OR #lx_Start_Positioning_m THEN
	                #lx_Start_Positioning_m := FALSE;
	                #li_StepCase            := 50;
	            END_IF;
	            
	        50: // Position vertical/horizontal HBW
	            "gtyp_SSC".Horizontal_Axis.di_Target_Position := #ldi_Pos_Horizontal;
	            "gtyp_SSC".Horizontal_Axis.x_Start_Positioning := TRUE;
	            "gtyp_SSC".Vertical_Axis.di_Target_Position := #ldi_Pos_Vertical;
	            "gtyp_SSC".Vertical_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_SSC".Horizontal_Axis.di_Actual_Position <= (#ldi_Pos_Horizontal + "gtyp_SSC".Horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_SSC".Horizontal_Axis.di_Actual_Position >= (#ldi_Pos_Horizontal - "gtyp_SSC".Horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_SSC".Horizontal_Axis.x_Position_Reached THEN
	                "gtyp_SSC".Horizontal_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_SSC".Vertical_Axis.di_Actual_Position <= (#ldi_Pos_Vertical + "gtyp_SSC".Vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_SSC".Vertical_Axis.di_Actual_Position >= (#ldi_Pos_Vertical - "gtyp_SSC".Vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_SSC".Vertical_Axis.x_Position_Reached THEN
	                "gtyp_SSC".Vertical_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_SSC".Horizontal_Axis.di_Actual_Position <= (#ldi_Pos_Horizontal + "gtyp_SSC".Horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_SSC".Horizontal_Axis.di_Actual_Position >= (#ldi_Pos_Horizontal - "gtyp_SSC".Horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_SSC".Horizontal_Axis.x_Position_Reached
	                AND ("gtyp_SSC".Vertical_Axis.di_Actual_Position <= (#ldi_Pos_Vertical + "gtyp_SSC".Vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_SSC".Vertical_Axis.di_Actual_Position >= (#ldi_Pos_Vertical - "gtyp_SSC".Vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_SSC".Vertical_Axis.x_Position_Reached THEN
	                "gtyp_SSC".Horizontal_Axis.x_Start_Positioning := FALSE;
	                "gtyp_SSC".Vertical_Axis.x_Start_Positioning := FALSE;
	                "gtyp_Setup".x_Start_Positioning := FALSE;
	                #li_StepCase := 60;
	            END_IF;
	            
	        60: // Deciding which doing
	            
	            // Start new Positioning
	            IF "gtyp_Setup".x_Start_Positioning OR "gtyp_Setup".x_Home_Positioning THEN
	                #lx_Start_Positioning_m := TRUE;
	                #li_StepCase            := 10;
	            ELSIF #lfb_R_Trig_Deaktivate.Q THEN
	                "gtyp_Setup".x_Home_Positioning := FALSE;
	                #li_StepCase                    := 70;
	            END_IF;
	            
	        70: //homing vertical/horizontal axis
	            
	            "gtyp_SSC".Horizontal_Axis.x_Reference := TRUE;
	            "gtyp_SSC".Vertical_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_SSC".Horizontal_Axis.x_Referenced AND NOT "gtyp_SSC".Vertical_Axis.x_Referenced THEN
	                #li_StepCase := 80;
	            END_IF;
	            
	        80: // homed vertical/horizontal axis
	            IF "gtyp_SSC".Horizontal_Axis.x_Referenced THEN
	                "gtyp_SSC".Horizontal_Axis.x_Reference := FALSE;
	            END_IF;
	            IF "gtyp_SSC".Vertical_Axis.x_Referenced THEN
	                "gtyp_SSC".Vertical_Axis.x_Reference := FALSE;
	            END_IF;
	            
	            IF "gtyp_SSC".Horizontal_Axis.x_Referenced AND "gtyp_SSC".Vertical_Axis.x_Referenced THEN
	                "gtyp_SSC".Horizontal_Axis.x_Reference := FALSE;
	                "gtyp_SSC".Vertical_Axis.x_Reference := FALSE;
	                #li_StepCase := 0;
	            END_IF;
	            
	            // Statement section ELSE    
	        ELSE
	            ;
	    END_CASE;
	    
	    IF (("gtyp_Setup".i_Pos_Selection > 0)
	        AND ("gtyp_Setup".i_Pos_Selection < 21)) THEN
	        // Reload Pos Value
	        "gtyp_Setup".di_Pos_Horizontal := #ldi_Pos_Horizontal;
	        "gtyp_Setup".di_Pos_Vertical := #ldi_Pos_Vertical;
	        "gtyp_Setup".di_Pos_Rotate := 0;
	    END_IF;
	ELSE
	    #lx_Init := TRUE;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "PRG_VGR_Axis_rotate"
TITLE = Program Axis rotate VGR
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
   VAR 
      lx_Init { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lfb_rotate_Axis { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Axis";
   END_VAR


BEGIN
	IF #lx_Init THEN
	    
	    // FB Axis rotate
	    #lfb_rotate_Axis(ini_Axis           := 3,
	                indi_Increment          := "gtyp_VGR".rotate_Axis.di_Increment,
	                inx_Ref_Switch          := "IX_VGR_RefSwitchRotate_I3",
	                inx_Referencing         := "gtyp_VGR".rotate_Axis.x_Reference,
	                inx_Start_Positioning   := "gtyp_VGR".rotate_Axis.x_Start_Positioning,
	                indi_Target_Position    := "gtyp_VGR".rotate_Axis.di_Target_Position,
	                ini_PWM                 := "gtyp_VGR".rotate_Axis.i_PWM,
	                inouttyp_Config         := "gtyp_VGR".rotate_Axis.Config,
	                inouttyp_Setup          := "gtyp_SetupAxis");
	    
	    "QX_VGR_M3_RotateClockwise_Q5"          := #lfb_rotate_Axis.outx_Motor_Neg;
	    "QX_VGR_M3_RotateCounterclockwise_Q6"   := #lfb_rotate_Axis.outx_Motor_Pos;
	    "QW_VGR_PWM_Rotate_M3"                  := #lfb_rotate_Axis.outi_Motor_PWM;
	    "gtyp_VGR".rotate_Axis.di_Actual_Position := #lfb_rotate_Axis.outdi_Actual_Position;
	    "gtyp_VGR".rotate_Axis.x_Referenced       := #lfb_rotate_Axis.outx_Referenced;
	    "gtyp_VGR".rotate_Axis.x_Position_Reached := #lfb_rotate_Axis.outx_Position_Reached;
	ELSE
	    #lx_Init := TRUE;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "PRG_SLD_Calibration_Color"
TITLE = Program Calibration Color Sensor SLD
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
   VAR 
      lx_Init { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Start_TON_Wait { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Start_Positioning_m { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lt_TON_Wait { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;
      li_StepCase { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      lw_ColorValueMin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
      ldi_Pos_Horizontal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      ldi_Pos_Vertical { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      lfb_R_Trig_Deaktivate {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      lfb_TON_Wait {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
   END_VAR


BEGIN
	IF #lx_Init THEN
	    
	    // FB TON Wait
	    #lfb_TON_Wait(IN := #lx_Start_TON_Wait,
	                  PT := #lt_TON_Wait);
	    
	    #lfb_R_Trig_Deaktivate(CLK:= NOT "gtyp_Setup".x_Color_Sensor_Calibration
	                           OR NOT ("gtyp_Setup".i_Color_Sensor_Selection = 2));
	    // Deaktivate step 0   
	    IF #lfb_R_Trig_Deaktivate.Q THEN
	        "gtyp_Setup".x_Calculate_Value_Color := FALSE;
	        "gtyp_Setup".x_Set_Calib_Value_Color_Blue := FALSE;
	        "gtyp_Setup".x_Set_Calib_Value_Color_Red := FALSE;
	        "gtyp_Setup".x_Set_Calib_Value_Color_White := FALSE;
	        "gtyp_Setup".w_Calib_ColorValue_Blue := 0;
	        "gtyp_Setup".w_Calib_ColorValue_Red := 0;
	        "gtyp_Setup".w_Calib_ColorValue_White := 0;
	        "gtyp_Setup".w_Threshold_Red_Blue := 0;
	        "gtyp_Setup".w_Threshold_White_Red := 0;
	        "QX_SLD_M1_ConveyorBelt_Q1" := FALSE;
	        #lw_ColorValueMin := 16#FF;
	        #li_StepCase            := 0;
	    END_IF;
	    
	    // step chain HBW
	    CASE #li_StepCase OF
	            
	        0:  // init
	            #lx_Start_TON_Wait := FALSE;
	            #li_StepCase := 10;
	            
	        10:  // Set Calibration activ?
	            IF "gtyp_Setup".x_Color_Sensor_Calibration
	                AND ("gtyp_Setup".i_Color_Sensor_Selection = 2) THEN
	                "gtyp_Setup".x_Calculate_Value_Color := FALSE;
	                "gtyp_Setup".x_Set_Calib_Value_Color_Blue := FALSE;
	                "gtyp_Setup".x_Set_Calib_Value_Color_Red := FALSE;
	                "gtyp_Setup".x_Set_Calib_Value_Color_White := FALSE;
	                "gtyp_Setup".w_Calib_ColorValue_Blue := 0;
	                "gtyp_Setup".w_Calib_ColorValue_Red := 0;
	                "gtyp_Setup".w_Calib_ColorValue_White := 0;
	                "gtyp_Setup".w_Threshold_Red_Blue := 0;
	                "gtyp_Setup".w_Threshold_White_Red := 0;
	                "QX_SLD_M1_ConveyorBelt_Q1" := FALSE;
	                #lw_ColorValueMin := 16#FFFF;
	                #li_StepCase := 20;
	            END_IF;
	            
	        20: // wait for set Values or Calculate
	            
	            IF NOT "IX_SLD_LightBarrierInlet_I2" THEN
	                "QX_SLD_M1_ConveyorBelt_Q1" := TRUE;
	                #lw_ColorValueMin := 16#FFFF;
	            END_IF;
	                
	            IF #lw_ColorValueMin > "IW_SLD_ColorSensor_A4" THEN
	                #lw_ColorValueMin := "IW_SLD_ColorSensor_A4";
	            END_IF;
	            
	            IF NOT "IX_SLD_LightBarrierBehindColorSensor_I3" THEN
	                "QX_SLD_M1_ConveyorBelt_Q1" := FALSE;
	            END_IF;
	            
	            // Start new Positioning
	            IF "gtyp_Setup".x_Set_Calib_Value_Color_Blue THEN
	                "gtyp_Setup".w_Calib_ColorValue_Blue := #lw_ColorValueMin;
	                "gtyp_Setup".x_Set_Calib_Value_Color_Blue := FALSE;
	            ELSIF "gtyp_Setup".x_Set_Calib_Value_Color_Red THEN
	                "gtyp_Setup".w_Calib_ColorValue_Red := #lw_ColorValueMin;
	                "gtyp_Setup".x_Set_Calib_Value_Color_Red := FALSE;
	            ELSIF "gtyp_Setup".x_Set_Calib_Value_Color_White THEN
	                "gtyp_Setup".w_Calib_ColorValue_White := #lw_ColorValueMin;
	                "gtyp_Setup".x_Set_Calib_Value_Color_White := FALSE;
	            END_IF;
	            
	            "gtyp_Setup".w_Threshold_White_Red := "gtyp_Setup".w_Calib_ColorValue_White + (("gtyp_Setup".w_Calib_ColorValue_Red - "gtyp_Setup".w_Calib_ColorValue_White) / 2);
	            "gtyp_Setup".w_Threshold_Red_Blue := "gtyp_Setup".w_Calib_ColorValue_Red + (("gtyp_Setup".w_Calib_ColorValue_Blue - "gtyp_Setup".w_Calib_ColorValue_Red) / 2);
	            
	            IF "gtyp_Setup".x_Calculate_Value_Color THEN
	                "gtyp_SLD".w_Threshold_White_Red := "gtyp_Setup".w_Threshold_White_Red;
	                "gtyp_SLD".w_Threshold_Red_Blue := "gtyp_Setup".w_Threshold_Red_Blue;
	                "gtyp_Setup".x_Calculate_Value_Color := FALSE;
	            END_IF;
	            
	            // Statement section ELSE    
	        ELSE
	            ;
	    END_CASE;
	    
	    IF ("gtyp_Setup".i_Color_Sensor_Selection = 2) THEN
	        // Reload Pos Value
	        "gtyp_Setup".w_Actual_ColorValue := "IW_SLD_ColorSensor_A4";
	    END_IF;
	ELSE
	    #lx_Init := TRUE;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "PRG_SLD_Set_Counter_Values"
TITLE = Program Set counter Values SLD
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
   VAR 
      lx_Init { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lfb_R_Trig_Calib_activ {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
   END_VAR


BEGIN
	IF #lx_Init THEN
	    
	    // Reload act. Counter Values
	    IF NOT "gtyp_Setup".x_Counter_Value_Calibration THEN
	        "gtyp_Setup".i_Calib_CounterValue_Blue := "gtyp_SLD".i_CounterValue_Blue;
	        "gtyp_Setup".i_Calib_CounterValue_Red := "gtyp_SLD".i_CounterValue_Red;
	        "gtyp_Setup".i_Calib_CounterValue_White := "gtyp_SLD".i_CounterValue_White;
	    END_IF;
	        
	    // Set Counter Values   
	    IF "gtyp_Setup".x_Set_CounterValues AND "gtyp_Setup".x_Counter_Value_Calibration THEN
	        "gtyp_SLD".i_CounterValue_Blue := "gtyp_Setup".i_Calib_CounterValue_Blue;
	        "gtyp_SLD".i_CounterValue_Red := "gtyp_Setup".i_Calib_CounterValue_Red;
	        "gtyp_SLD".i_CounterValue_White := "gtyp_Setup".i_Calib_CounterValue_White;
	        "gtyp_Setup".x_Set_CounterValues := FALSE;
	    END_IF;
	   
	ELSE
	    #lx_Init := TRUE;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "PRG_NFC"
TITLE = Program NFC
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
   VAR 
      lx_Init { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Start { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Time_Wait { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Time_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      li_StepCase { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ldt_MQTT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Date_And_Time;
      ldt_Delete_old { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LDT;
      ldt_Read_old { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LDT;
      li_Return_LDT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      lfb_TON_Error {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      lfb_TON_Wait {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
   END_VAR


BEGIN
	IF #lx_Init THEN
	    
	    // runtime monitoring error
	    #lfb_TON_Error(IN:= #lx_Time_Error,
	                   PT:= T#30s);
	    
	    // runtime monitoring read uid
	    #lfb_TON_Wait(IN := #lx_Time_Wait,
	                  PT := T#5s);
	     
	     // step chain NFC
	    CASE #li_StepCase OF
	            
	        0:  // init
	            #lx_Time_Wait                := FALSE;
	            "gtyp_VGR"."x_NFC_Completed" := FALSE;
	            
	            // delete and write first state to chip
	            IF "gtyp_VGR".x_NFC_Start_First AND NOT "gtyp_VGR".x_Workpiece_NiO THEN
	                "gtyp_Interface_TXT_Controler".Subscribe.State_NFC_Device.Workpiece.s_state := '';
	                "gtyp_Interface_TXT_Controler".Subscribe.State_NFC_Device.Workpiece.s_type := '';
	                
	                "gtyp_Interface_TXT_Controler".Publish.ActionButtonNFCModule.s_cmd := '';
	                #li_StepCase := 10;
	                // write color or processed finished to chip
	            ELSIF "gtyp_VGR".x_NFC_Start AND NOT "gtyp_VGR".x_Workpiece_NiO THEN
	                "gtyp_Interface_TXT_Controler".Publish.ActionButtonNFCModule.s_cmd := '';
	                #li_StepCase := 40;
	                // read chip for delete HBW
	            ELSIF "QX_SSC_LED_Green_Q5" AND NOT "gtyp_VGR".x_Workpiece_NiO THEN
	                #ldt_Read_old := "gtyp_Interface_Dashboard".Publish.ActionButtonNFCModule.ldt_ts;
	                "gtyp_VGR".x_NFC_Start_First := FALSE;
	                "gtyp_VGR".x_NFC_Start := FALSE;
	                "gtyp_Interface_TXT_Controler".Publish.ActionButtonNFCModule.s_cmd := '';
	                #li_StepCase := 60;
	            END_IF;
	            
	        10: // delete
	            
	            "gtyp_Interface_TXT_Controler".Publish.ActionButtonNFCModule.s_cmd := 'delete';
	            #li_Return_LDT := RD_SYS_T(#ldt_MQTT);
	            "gtyp_Interface_TXT_Controler".Publish.ActionButtonNFCModule.ldt_ts := DT_TO_LDT(#ldt_MQTT);
	            
	            #li_StepCase := 20;
	            
	        20: // wait to answer from dashboard
	            #lx_Time_Error := TRUE;
	            IF ("gtyp_Interface_TXT_Controler".Subscribe.State_NFC_Device.ldt_ts > "gtyp_Interface_TXT_Controler".Publish.ActionButtonNFCModule.ldt_ts)
	                AND ("gtyp_Interface_TXT_Controler".Subscribe.State_NFC_Device.Workpiece.s_type = 'NONE')
	                AND ("gtyp_Interface_TXT_Controler".Subscribe.State_NFC_Device.Workpiece.s_state <> '')
	                AND ("gtyp_Interface_TXT_Controler".Subscribe.State_NFC_Device.Workpiece.s_id <> '') THEN
	                "gtyp_VGR".Workpiece.s_id := "gtyp_Interface_TXT_Controler".Subscribe.State_NFC_Device.Workpiece.s_id;
	                #lx_Time_Error := FALSE;
	                #li_StepCase := 30;
	            END_IF;
	            // runtime error
	            IF #lfb_TON_Error.Q THEN
	                #lx_Time_Error := FALSE;
	                "gtyp_VGR".x_Workpiece_NiO := TRUE;
	                #li_StepCase := 0;
	            END_IF;
	            
	            
	        30: // wait of answer 
	            IF "gtyp_Interface_TXT_Controler".Subscribe.State_NFC_Device.Workpiece.s_id <> '' THEN
	                #li_StepCase := 40;
	            END_IF;
	            
	        40:  // write
	            "gtyp_Interface_TXT_Controler".Publish.ActionButtonNFCModule.History            := "gtyp_VGR".History;
	            "gtyp_Interface_TXT_Controler".Publish.ActionButtonNFCModule.Workpiece.s_type   := "gtyp_VGR".Workpiece.s_type;
	            "gtyp_Interface_TXT_Controler".Publish.ActionButtonNFCModule.Workpiece.s_state  := "gtyp_VGR".Workpiece.s_state;
	            
	            #li_Return_LDT := RD_SYS_T(#ldt_MQTT);
	            
	            "gtyp_Interface_TXT_Controler".Publish.ActionButtonNFCModule.s_cmd  := 'write';
	            "gtyp_Interface_TXT_Controler".Publish.ActionButtonNFCModule.ldt_ts := DT_TO_LDT(#ldt_MQTT);
	            
	            #li_StepCase := 50;
	            
	        50: // wait of answer write 
	            #lx_Time_Error := TRUE;
	            IF ("gtyp_Interface_TXT_Controler".Subscribe.State_NFC_Device.ldt_ts > "gtyp_Interface_TXT_Controler".Publish.ActionButtonNFCModule.ldt_ts) THEN
	                #lx_Time_Error := FALSE;
	                #li_StepCase := 80;
	            END_IF;
	            // runtime error
	            IF #lfb_TON_Error.Q THEN
	                #lx_Time_Error := FALSE;
	                "gtyp_VGR".x_Workpiece_NiO := TRUE;
	                #li_StepCase := 0;
	            END_IF;
	            
	        60: // read uid cmd
	            
	            #li_Return_LDT := RD_SYS_T(#ldt_MQTT);
	            
	            "gtyp_Interface_TXT_Controler".Publish.ActionButtonNFCModule.s_cmd := 'read_uid';
	            "gtyp_Interface_TXT_Controler".Publish.ActionButtonNFCModule.ldt_ts := DT_TO_LDT(#ldt_MQTT);
	            #lx_Time_Wait   := TRUE;
	            #li_StepCase    := 70;
	            
	        70: // wait of answer read_uid 
	            IF NOT "QX_SSC_LED_Green_Q5" OR #lfb_TON_Wait.Q OR ("gtyp_Interface_TXT_Controler".Subscribe.State_NFC_Device.ldt_ts > "gtyp_Interface_TXT_Controler".Publish.ActionButtonNFCModule.ldt_ts) THEN
	                IF LEN("gtyp_Interface_TXT_Controler".Subscribe.State_NFC_Device.Workpiece.s_id) = 8 THEN
	                    "gtyp_Setup".x_Clean_Rack_HBW := TRUE;
	                END_IF;
	                #lx_Time_Wait := FALSE;
	                "gtyp_Interface_TXT_Controler".Subscribe.State_NFC_Device.Workpiece.s_id := '';
	                #li_StepCase := 0;
	            END_IF;
	            
	        80: // completed
	            
	            "gtyp_VGR"."x_NFC_Completed" := TRUE;
	            
	            IF NOT "gtyp_VGR".x_NFC_Start AND NOT "gtyp_VGR".x_NFC_Start_First THEN
	                "gtyp_VGR"."x_NFC_Completed" := FALSE;
	                #lx_Start := FALSE;
	                #li_StepCase := 0;
	            END_IF;
	            
	            // Statement section ELSE
	            ELSE  
	                ;
	    END_CASE;
	 
	ELSE
	    #lx_Init := TRUE;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "PRG_HBW_Ablauf"
TITLE = Program Ablauf HBW
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
   VAR 
      lx_Init { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Start_TON_Wait { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Time_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lt_TON_Wait { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;
      lx_Start_TON_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Storage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ldt_MQTT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Date_And_Time;
      li_Return_LDT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      lldt_Outsource { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LDT;
      li_Lights { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      li_Lights_old { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      li_Counter_Hor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      li_Counter_Ver { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      li_Counter_Act_Hor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      li_Counter_Act_Ver { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      li_Counter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      li_StepCase { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ldi_PosRack_Horizontal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      ldi_PosRack_Vertical { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      ls_Color { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;
      lfb_TON_State {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      lfb_TON_ConveyerBelt_Out {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      lfb_TON_Wait {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      lfb_TON_Error {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
   END_VAR


BEGIN
	IF #lx_Init THEN
	        
	    // Restart after set Positioning
	    IF "gtyp_Setup".x_Set_Pos_Activ THEN
	        #li_StepCase := 0;
	    END_IF;
	    
	    // wait time state
	    #lfb_TON_State(IN := NOT #lx_Start_TON_State,
	                    PT := T#2s);
	    
	    // runtime monitoring error
	    #lfb_TON_Error(IN := #lx_Time_Error,
	                   PT := T#30s);
	    
	    // state of the Stock HBW cyclically transmitted to the cloud
	     IF (#lfb_TON_State.Q OR (#li_Lights <> #li_Lights_old)) AND NOT #lx_Start_TON_State THEN
	        #li_Lights_old := #li_Lights;
	        #lx_Start_TON_State := TRUE;
	        #li_Return_LDT := RD_SYS_T(#ldt_MQTT);
	        "gtyp_Interface_Dashboard".Subscribe.Stock_HBW.StockItem := "gtyp_HBW".Rack_Workpiece;
	        "gtyp_Interface_Dashboard".Subscribe.Stock_HBW.ldt_ts := DT_TO_LDT(#ldt_MQTT);
	        
	        "gtyp_Interface_Dashboard".Subscribe.State_HBW.ldt_ts := DT_TO_LDT(#ldt_MQTT);
	        "gtyp_Interface_Dashboard".Subscribe.State_HBW.i_code := #li_Lights;
	        "gtyp_Interface_Dashboard".Subscribe.State_HBW.s_description := '';
	        "gtyp_Interface_Dashboard".Subscribe.State_HBW.s_station := 'hbw';
	        "gtyp_Interface_Dashboard".Subscribe.State_HBW.s_target := '';
	    END_IF;
	    
	    // restart wait time state
	    IF NOT #lfb_TON_State.Q AND #lx_Start_TON_State THEN
	        #lx_Start_TON_State := FALSE;
	    END_IF;
	    
	    // FB TON Wait
	    #lfb_TON_Wait(IN := #lx_Start_TON_Wait,
	                    PT := #lt_TON_Wait);
	      
	    //Run-on time Conveyer Belt
	    #lfb_TON_ConveyerBelt_Out(IN := NOT "IX_HBW_LightBarrierOutside_I3",
	                              PT := T#300ms);
	    
	    // Reload the calibration values - Rack Array
	    // A
	    "gtyp_HBW".Rack_Pos[1, 1].di_PosRack_Horizontal := "gtyp_HBW".di_PosRack_A1_Horizontal;
	    "gtyp_HBW".Rack_Pos[2, 1].di_PosRack_Horizontal := "gtyp_HBW".di_PosRack_A1_Horizontal;
	    "gtyp_HBW".Rack_Pos[3, 1].di_PosRack_Horizontal := "gtyp_HBW".di_PosRack_A1_Horizontal;
	    // B
	    "gtyp_HBW".Rack_Pos[1, 2].di_PosRack_Horizontal := "gtyp_HBW".di_PosRack_B2_Horizontal;
	    "gtyp_HBW".Rack_Pos[2, 2].di_PosRack_Horizontal := "gtyp_HBW".di_PosRack_B2_Horizontal;
	    "gtyp_HBW".Rack_Pos[3, 2].di_PosRack_Horizontal := "gtyp_HBW".di_PosRack_B2_Horizontal;
	    // C
	    "gtyp_HBW".Rack_Pos[1, 3].di_PosRack_Horizontal := "gtyp_HBW".di_PosRack_C3_Horizontal;
	    "gtyp_HBW".Rack_Pos[2, 3].di_PosRack_Horizontal := "gtyp_HBW".di_PosRack_C3_Horizontal;
	    "gtyp_HBW".Rack_Pos[3, 3].di_PosRack_Horizontal := "gtyp_HBW".di_PosRack_C3_Horizontal;
	    // 1
	    "gtyp_HBW".Rack_Pos[1, 1].di_PosRack_Vertical := "gtyp_HBW".di_PosRack_A1_Vertical;
	    "gtyp_HBW".Rack_Pos[1, 2].di_PosRack_Vertical := "gtyp_HBW".di_PosRack_A1_Vertical;
	    "gtyp_HBW".Rack_Pos[1, 3].di_PosRack_Vertical := "gtyp_HBW".di_PosRack_A1_Vertical;
	    // 2
	    "gtyp_HBW".Rack_Pos[2, 1].di_PosRack_Vertical := "gtyp_HBW".di_PosRack_B2_Vertical;
	    "gtyp_HBW".Rack_Pos[2, 2].di_PosRack_Vertical := "gtyp_HBW".di_PosRack_B2_Vertical;
	    "gtyp_HBW".Rack_Pos[2, 3].di_PosRack_Vertical := "gtyp_HBW".di_PosRack_B2_Vertical;
	    // 3
	    "gtyp_HBW".Rack_Pos[3, 1].di_PosRack_Vertical := "gtyp_HBW".di_PosRack_C3_Vertical;
	    "gtyp_HBW".Rack_Pos[3, 2].di_PosRack_Vertical := "gtyp_HBW".di_PosRack_C3_Vertical;
	    "gtyp_HBW".Rack_Pos[3, 3].di_PosRack_Vertical := "gtyp_HBW".di_PosRack_C3_Vertical;
	    
	    // step chain HBW
	    CASE #li_StepCase OF
	            
	        0:  // init
	            #lx_Start_TON_Wait := FALSE;
	            #lx_Time_Error := FALSE;
	            
	            "gtyp_HBW".Horizontal_Axis.x_Start_Positioning := FALSE;
	            "gtyp_HBW".Vertical_Axis.x_Start_Positioning := FALSE;
	            "gtyp_HBW".Horizontal_Axis.x_Reference := FALSE;
	            "gtyp_HBW".Vertical_Axis.x_Reference := FALSE;
	            
	            IF NOT "gtyp_HBW".x_Error AND NOT "gtyp_Setup".x_Set_Pos_Activ THEN
	                #li_StepCase := 10;
	            END_IF;
	            
	        10:  // Position Cantilever Back
	            #li_Lights := 2;
	            IF "IX_HBW_SwitchCantileverFront_I5" OR NOT "IX_HBW_SwitchCantileverBack_I6" THEN
	                "QX_HBW_M4_CantileverBackward_Q8" := TRUE;
	                "QX_HBW_M4_CantileverForward_Q7" := FALSE;
	            ELSIF NOT "IX_HBW_SwitchCantileverFront_I5" AND "IX_HBW_SwitchCantileverBack_I6" THEN
	                "QX_HBW_M4_CantileverBackward_Q8" := FALSE;
	                "QX_HBW_M4_CantileverForward_Q7" := FALSE;
	                #li_StepCase := 20;
	            END_IF;
	            
	        20: //homing vertical/horizontal axis
	            
	            "gtyp_HBW".Horizontal_Axis.x_Reference := TRUE;
	            "gtyp_HBW".Vertical_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_HBW".Horizontal_Axis.x_Referenced AND NOT "gtyp_HBW".Vertical_Axis.x_Referenced THEN
	                #li_StepCase := 30;
	            END_IF;
	            
	        30: // homed vertical/horizontal axis
	            IF "gtyp_HBW".Horizontal_Axis.x_Referenced THEN
	                "gtyp_HBW".Horizontal_Axis.x_Reference := FALSE;
	            END_IF;
	            IF "gtyp_HBW".Vertical_Axis.x_Referenced THEN
	                "gtyp_HBW".Vertical_Axis.x_Reference := FALSE;
	            END_IF;
	            
	            IF "gtyp_HBW".Horizontal_Axis.x_Referenced AND "gtyp_HBW".Vertical_Axis.x_Referenced THEN
	                "gtyp_HBW".Horizontal_Axis.x_Reference := FALSE;
	                "gtyp_HBW".Vertical_Axis.x_Reference := FALSE;
	                #li_StepCase := 40;
	            END_IF;
	            
	        40: // Deciding which route to take
	            
	            #li_Lights := 1;
	            #lx_Storage := FALSE;
	            
	            // Procedure - storage
	            IF "gtyp_VGR".x_HBW_Storage THEN
	                #li_Lights := 2;
	                #li_StepCase := 50;
	            // Procedure - outsource
	            ELSIF "gtyp_VGR".x_HBW_Outsource THEN
	                #li_Lights := 2;
	                #li_StepCase := 60;
	            END_IF;
	            
	        50: // Evaluate the next free position in the high-bay warehouse
	            FOR #li_Counter_Hor := 1 TO 3 DO
	                FOR #li_Counter_Ver := 1 TO 3 DO
	                    IF "gtyp_HBW".Rack_Workpiece[#li_Counter_Ver, #li_Counter_Hor].s_id = '0' THEN
	                        #li_Counter_Act_Hor := #li_Counter_Hor;
	                        #li_Counter_Act_Ver := #li_Counter_Ver;
	                        #ldi_PosRack_Horizontal := "gtyp_HBW".Rack_Pos[#li_Counter_Ver, #li_Counter_Hor].di_PosRack_Horizontal;
	                        #ldi_PosRack_Vertical := "gtyp_HBW".Rack_Pos[#li_Counter_Ver, #li_Counter_Hor].di_PosRack_Vertical;
	                        #li_StepCase := 70;
	                    END_IF;
	                    IF #li_StepCase = 70 THEN
	                        EXIT;
	                    END_IF;
	                END_FOR;
	                IF #li_StepCase = 70 THEN
	                    EXIT;
	                END_IF;
	            END_FOR;
	            
	        60: // Evaluate the workpiece first stored in the high-bay warehouse with the appropriate color
	            #li_Return_LDT := RD_SYS_T(#ldt_MQTT);
	            #lldt_Outsource := #ldt_MQTT;
	            
	            FOR #li_Counter_Hor := 1 TO 3 DO
	                FOR #li_Counter_Ver := 1 TO 3 DO
	                    IF ("gtyp_VGR".s_HBW_Outsource_Typ = "gtyp_HBW".Rack_Workpiece[#li_Counter_Ver, #li_Counter_Hor].s_type)
	                        AND (#lldt_Outsource > "gtyp_HBW".Rack_History[#li_Counter_Ver, #li_Counter_Hor].History[3].ldt_ts)
	                        AND NOT ("gtyp_HBW".Rack_History[#li_Counter_Ver, #li_Counter_Hor].History[3].ldt_ts = LDT#1970-01-01-00:00:00) THEN
	                        #lldt_Outsource := "gtyp_HBW".Rack_History[#li_Counter_Ver, #li_Counter_Hor].History[3].ldt_ts;
	                        #li_Counter_Act_Hor := #li_Counter_Hor;
	                        #li_Counter_Act_Ver := #li_Counter_Ver;
	                        #ldi_PosRack_Horizontal := "gtyp_HBW".Rack_Pos[#li_Counter_Ver, #li_Counter_Hor].di_PosRack_Horizontal;
	                        #ldi_PosRack_Vertical := "gtyp_HBW".Rack_Pos[#li_Counter_Ver, #li_Counter_Hor].di_PosRack_Vertical;
	                    END_IF;
	                END_FOR;
	            END_FOR;
	            
	            IF (#li_Counter_Act_Hor = 4) OR (#li_Counter_Act_Ver = 4) THEN
	                #li_StepCase := 40;
	            ELSE
	                #li_StepCase := 70;
	            END_IF;
	            
	        70: // Position vertical/horizontal HBW
	            "gtyp_HBW".Horizontal_Axis.di_Target_Position := #ldi_PosRack_Horizontal;
	            "gtyp_HBW".Horizontal_Axis.x_Start_Positioning := TRUE;
	            "gtyp_HBW".Vertical_Axis.di_Target_Position := #ldi_PosRack_Vertical;
	            "gtyp_HBW".Vertical_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_HBW".Horizontal_Axis.di_Actual_Position <= (#ldi_PosRack_Horizontal + "gtyp_HBW".Horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_HBW".Horizontal_Axis.di_Actual_Position >= (#ldi_PosRack_Horizontal - "gtyp_HBW".Horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_HBW".Horizontal_Axis.x_Position_Reached THEN
	                "gtyp_HBW".Horizontal_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_HBW".Vertical_Axis.di_Actual_Position <= (#ldi_PosRack_Vertical + "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_HBW".Vertical_Axis.di_Actual_Position >= (#ldi_PosRack_Vertical - "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_HBW".Vertical_Axis.x_Position_Reached THEN
	                "gtyp_HBW".Vertical_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_HBW".Horizontal_Axis.di_Actual_Position <= (#ldi_PosRack_Horizontal + "gtyp_HBW".Horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_HBW".Horizontal_Axis.di_Actual_Position >= (#ldi_PosRack_Horizontal - "gtyp_HBW".Horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_HBW".Horizontal_Axis.x_Position_Reached
	                AND ("gtyp_HBW".Vertical_Axis.di_Actual_Position <= (#ldi_PosRack_Vertical + "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_HBW".Vertical_Axis.di_Actual_Position >= (#ldi_PosRack_Vertical - "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_HBW".Vertical_Axis.x_Position_Reached THEN
	                "gtyp_HBW".Horizontal_Axis.x_Start_Positioning := FALSE;
	                "gtyp_HBW".Vertical_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 80;
	            END_IF;
	            
	        80: // Position Cantilever Forward HBW
	            
	            "QX_HBW_M4_CantileverBackward_Q8" := FALSE;
	            "QX_HBW_M4_CantileverForward_Q7" := TRUE;
	            
	            IF "IX_HBW_SwitchCantileverFront_I5" AND NOT "IX_HBW_SwitchCantileverBack_I6" THEN
	                "QX_HBW_M4_CantileverBackward_Q8" := FALSE;
	                "QX_HBW_M4_CantileverForward_Q7" := FALSE;
	                #li_StepCase := 90;
	            END_IF;
	            
	        90: // Position vertical+offset HBW
	            "gtyp_HBW".Vertical_Axis.di_Target_Position := #ldi_PosRack_Vertical - "gtyp_HBW".di_Offset_Pos_Rack_Vertical;
	            "gtyp_HBW".Vertical_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_HBW".Vertical_Axis.di_Actual_Position <= (#ldi_PosRack_Vertical - "gtyp_HBW".di_Offset_Pos_Rack_Vertical + "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_HBW".Vertical_Axis.di_Actual_Position >= (#ldi_PosRack_Vertical - "gtyp_HBW".di_Offset_Pos_Rack_Vertical - "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_HBW".Vertical_Axis.x_Position_Reached THEN
	                "gtyp_HBW".Vertical_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 100;
	            END_IF;
	            
	        100: // Position vertical Back HBW
	            
	            "QX_HBW_M4_CantileverBackward_Q8" := TRUE;
	            "QX_HBW_M4_CantileverForward_Q7" := FALSE;
	            
	            IF NOT "IX_HBW_SwitchCantileverFront_I5" AND "IX_HBW_SwitchCantileverBack_I6" THEN
	                IF "gtyp_VGR".x_HBW_Storage THEN
	                    "gtyp_HBW".Rack_Workpiece[#li_Counter_Act_Ver, #li_Counter_Act_Hor].s_id := '';
	                ELSIF "gtyp_VGR".x_HBW_Outsource THEN
	                    "gtyp_Interface_Dashboard".Subscribe.State_HBW.x_active := TRUE;
	                    "gtyp_HBW".History := "gtyp_HBW".Rack_History[#li_Counter_Act_Ver, #li_Counter_Act_Hor].History;
	                    "gtyp_HBW".Workpiece := "gtyp_HBW".Rack_Workpiece[#li_Counter_Act_Ver, #li_Counter_Act_Hor];
	                    #li_Return_LDT := RD_SYS_T(#ldt_MQTT);
	                    "gtyp_HBW".History[4].i_code := 400;
	                    "gtyp_HBW".History[4].ldt_ts := DT_TO_LDT(#ldt_MQTT);
	                    
	                    "gtyp_HBW".Rack_Workpiece[#li_Counter_Act_Ver, #li_Counter_Act_Hor].s_id := '';
	                    "gtyp_HBW".Rack_Workpiece[#li_Counter_Act_Ver, #li_Counter_Act_Hor].s_state := '';
	                    "gtyp_HBW".Rack_Workpiece[#li_Counter_Act_Ver, #li_Counter_Act_Hor].s_type := '';
	                    FOR #li_Counter := 1 TO 8 DO
	                        "gtyp_HBW".Rack_History[#li_Counter_Act_Ver, #li_Counter_Act_Hor].History[#li_Counter].i_code := 0;
	                        "gtyp_HBW".Rack_History[#li_Counter_Act_Ver, #li_Counter_Act_Hor].History[#li_Counter].ldt_ts := DT#1990-01-01-00:00:00;
	                    END_FOR;
	                END_IF;
	                "QX_HBW_M4_CantileverBackward_Q8" := FALSE;
	                "QX_HBW_M4_CantileverForward_Q7" := FALSE;
	                #li_StepCase := 110;
	            END_IF;
	            
	        110: // homing vertical/horizontal axis
	            
	            "gtyp_HBW".Horizontal_Axis.x_Reference := TRUE;
	            
	            "gtyp_HBW".Vertical_Axis.di_Target_Position := "gtyp_HBW".di_PosBelt_Vertical - "gtyp_HBW".di_Offset_Pos_Belt_Vertical;
	            "gtyp_HBW".Vertical_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_HBW".Vertical_Axis.di_Actual_Position <= ("gtyp_HBW".di_PosBelt_Vertical - "gtyp_HBW".di_Offset_Pos_Belt_Vertical + "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_HBW".Vertical_Axis.di_Actual_Position >= ("gtyp_HBW".di_PosBelt_Vertical - "gtyp_HBW".di_Offset_Pos_Belt_Vertical - "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_HBW".Vertical_Axis.x_Position_Reached THEN
	                "gtyp_HBW".Vertical_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF NOT "gtyp_HBW".Horizontal_Axis.x_Referenced THEN
	                #li_StepCase := 120;
	            END_IF;
	            
	        120: //homed vertical/horizontal axis
	            
	            IF "gtyp_HBW".Horizontal_Axis.x_Referenced THEN
	                "gtyp_HBW".Horizontal_Axis.x_Reference := FALSE;
	            END_IF;
	            
	            IF ("gtyp_HBW".Vertical_Axis.di_Actual_Position <= ("gtyp_HBW".di_PosBelt_Vertical - "gtyp_HBW".di_Offset_Pos_Belt_Vertical + "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_HBW".Vertical_Axis.di_Actual_Position >= ("gtyp_HBW".di_PosBelt_Vertical - "gtyp_HBW".di_Offset_Pos_Belt_Vertical - "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_HBW".Vertical_Axis.x_Position_Reached THEN
	                "gtyp_HBW".Vertical_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF "gtyp_HBW".Horizontal_Axis.x_Referenced
	                AND ("gtyp_HBW".Vertical_Axis.di_Actual_Position <= ("gtyp_HBW".di_PosBelt_Vertical - "gtyp_HBW".di_Offset_Pos_Belt_Vertical + "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_HBW".Vertical_Axis.di_Actual_Position >= ("gtyp_HBW".di_PosBelt_Vertical - "gtyp_HBW".di_Offset_Pos_Belt_Vertical - "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_HBW".Vertical_Axis.x_Position_Reached  THEN
	                "gtyp_HBW".Horizontal_Axis.x_Reference := FALSE;
	                "gtyp_HBW".Vertical_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 130;
	            END_IF;
	            
	        130: // Position vertical+offset/horizontal Belt
	            "gtyp_HBW".Horizontal_Axis.di_Target_Position := "gtyp_HBW".di_PosBelt_Horizontal;
	            "gtyp_HBW".Horizontal_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_HBW".Horizontal_Axis.di_Actual_Position <= ("gtyp_HBW".di_PosBelt_Horizontal + "gtyp_HBW".Horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_HBW".Horizontal_Axis.di_Actual_Position >= ("gtyp_HBW".di_PosBelt_Horizontal - "gtyp_HBW".Horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_HBW".Horizontal_Axis.x_Position_Reached THEN
	                "gtyp_HBW".Horizontal_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_HBW".Horizontal_Axis.di_Actual_Position <= ("gtyp_HBW".di_PosBelt_Horizontal + "gtyp_HBW".Horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_HBW".Horizontal_Axis.di_Actual_Position >= ("gtyp_HBW".di_PosBelt_Horizontal - "gtyp_HBW".Horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_HBW".Horizontal_Axis.x_Position_Reached THEN
	                "gtyp_HBW".Horizontal_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 140;
	            END_IF;
	            
	        140: // Position cantilever Forward Belt
	            
	            "QX_HBW_M4_CantileverBackward_Q8" := FALSE;
	            "QX_HBW_M4_CantileverForward_Q7" := TRUE;
	            
	            #lx_Time_Error := TRUE;
	            
	            IF "IX_HBW_SwitchCantileverFront_I5" AND NOT "IX_HBW_SwitchCantileverBack_I6" THEN
	                "QX_HBW_M4_CantileverBackward_Q8"   := FALSE;
	                "QX_HBW_M4_CantileverForward_Q7"    := FALSE;
	                #lx_Time_Error                      := FALSE;
	                #li_StepCase := 150;
	            END_IF;
	            
	            // runtime error
	            IF #lfb_TON_Error.Q THEN
	                #li_Lights := 4;
	                #lx_Time_Error := FALSE;
	                "QX_HBW_M1_ConveyorBeltBackward_Q2" := FALSE;
	                "QX_HBW_M1_ConveyorBeltForward_Q1" := FALSE;
	                "gtyp_Interface_Dashboard".Subscribe.State_HBW.x_active := FALSE;
	                "gtyp_HBW".x_Error := TRUE;
	                #li_StepCase := 0;
	            END_IF;
	            
	        150: // Position vertical Belt
	            "gtyp_HBW".Vertical_Axis.di_Target_Position := "gtyp_HBW".di_PosBelt_Vertical;
	            "gtyp_HBW".Vertical_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_HBW".Vertical_Axis.di_Actual_Position <= ("gtyp_HBW".di_PosBelt_Vertical + "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_HBW".Vertical_Axis.di_Actual_Position >= ("gtyp_HBW".di_PosBelt_Vertical - "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_HBW".Vertical_Axis.x_Position_Reached THEN
	                "gtyp_HBW".Vertical_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 160;
	            END_IF;
	            
	        160: // Start Conveyor Belt Forward
	            
	            #lx_Time_Error := TRUE;
	            
	            IF NOT "IX_HBW_LightBarrierInside_I2" THEN
	                "QX_HBW_M1_ConveyorBeltBackward_Q2" := FALSE;
	                "QX_HBW_M1_ConveyorBeltForward_Q1"  := TRUE;
	                #lx_Time_Error                      := FALSE;
	                #li_StepCase                        := 170;
	            END_IF;
	            
	            // runtime error
	            IF #lfb_TON_Error.Q THEN
	                #li_Lights := 4;
	                #lx_Time_Error := FALSE;
	                "QX_HBW_M1_ConveyorBeltBackward_Q2" := FALSE;
	                "QX_HBW_M1_ConveyorBeltForward_Q1" := FALSE;
	                "gtyp_Interface_Dashboard".Subscribe.State_HBW.x_active := FALSE;
	                "gtyp_HBW".x_Error := TRUE;
	                #li_StepCase := 0;
	            END_IF;
	            
	        170: //Run-on time reached Conveyor Belt Outside
	            
	            #lx_Time_Error := TRUE;
	            
	            IF #lfb_TON_ConveyerBelt_Out.Q THEN
	                "QX_HBW_M1_ConveyorBeltBackward_Q2" := FALSE;
	                "QX_HBW_M1_ConveyorBeltForward_Q1" := FALSE;
	                "gtyp_HBW".x_HBW_Container_Available := TRUE;
	                #lx_Time_Error := FALSE;
	                #li_StepCase := 180;
	            END_IF;
	            
	            // runtime error
	            IF #lfb_TON_Error.Q THEN
	                #li_Lights := 4;
	                #lx_Time_Error := FALSE;
	                "QX_HBW_M1_ConveyorBeltBackward_Q2" := FALSE;
	                "QX_HBW_M1_ConveyorBeltForward_Q1" := FALSE;
	                "gtyp_Interface_Dashboard".Subscribe.State_HBW.x_active := FALSE;
	                "gtyp_HBW".x_Error := TRUE;
	                #li_StepCase := 0;
	            END_IF;
	            
	        180: // VGR picked up - outsource
	            
	            #li_Lights := 1;
	            
	            IF "gtyp_VGR".x_HBW_PickedUp AND "gtyp_VGR".x_HBW_Outsource THEN
	                "gtyp_VGR".Workpiece := "gtyp_HBW".Workpiece;
	                "gtyp_VGR".History   := "gtyp_HBW".History;
	                "gtyp_HBW".Workpiece.s_id := '0';
	                "gtyp_HBW".Workpiece.s_state := '';
	                "gtyp_HBW".Workpiece.s_type := '';
	                FOR #li_Counter := 1 TO 8 DO
	                    "gtyp_HBW".History[#li_Counter].i_code := 0;
	                    "gtyp_HBW".History[#li_Counter].ldt_ts := DT#1990-01-01-00:00:00;
	                END_FOR;
	                "gtyp_HBW".x_HBW_Container_Available := FALSE;
	                "gtyp_HBW".x_HBW_PickedUp_Accepted := TRUE;
	                
	                "gtyp_Interface_Dashboard".Subscribe.State_HBW.x_active := FALSE;
	                
	                #li_Lights := 2;
	                #li_StepCase := 190;
	            // VGR discard - storage
	            ELSIF "gtyp_VGR".x_HBW_Discards AND "gtyp_VGR".x_HBW_Storage THEN
	                "gtyp_Interface_Dashboard".Subscribe.State_HBW.x_active := TRUE;
	                "gtyp_HBW".Workpiece := "gtyp_VGR".Workpiece;
	                "gtyp_HBW".History:= "gtyp_VGR".History;
	                "gtyp_HBW".x_HBW_Container_Available := FALSE;
	                "gtyp_HBW".x_HBW_Discards_Accepted := TRUE;
	                #lx_Storage := true;
	                
	                #li_Lights := 2;
	                #li_StepCase := 190;
	            END_IF;
	            
	        190: // Start Conveyor Belt Back
	            
	            IF NOT "gtyp_VGR".x_HBW_Discards AND NOT "gtyp_VGR".x_HBW_PickedUp THEN
	                "QX_HBW_M1_ConveyorBeltBackward_Q2" := TRUE;
	                "QX_HBW_M1_ConveyorBeltForward_Q1" := FALSE;
	                #li_StepCase := 200;
	            END_IF;
	            
	        200:  // Conveyor Belt inside reached
	            
	            #lx_Time_Error := TRUE;
	            
	            IF NOT "IX_HBW_LightBarrierInside_I2" THEN
	                "QX_HBW_M1_ConveyorBeltBackward_Q2" := FALSE;
	                "QX_HBW_M1_ConveyorBeltForward_Q1"  := FALSE;
	                #lx_Time_Error                      := FALSE;
	                #li_StepCase                        := 210;
	            END_IF;
	            
	            // runtime error
	            IF #lfb_TON_Error.Q THEN
	                #li_Lights := 4;
	                #lx_Time_Error := FALSE;
	                "QX_HBW_M1_ConveyorBeltBackward_Q2" := FALSE;
	                "QX_HBW_M1_ConveyorBeltForward_Q1" := FALSE;
	                "gtyp_Interface_Dashboard".Subscribe.State_HBW.x_active := FALSE;
	                "gtyp_HBW".x_Error := TRUE;
	                #li_StepCase := 0;
	            END_IF;
	            
	        210: // Position vertical+offset Belt
	            
	            "gtyp_HBW".Vertical_Axis.di_Target_Position := "gtyp_HBW".di_PosBelt_Vertical - "gtyp_HBW".di_Offset_Pos_Belt_Vertical;
	            "gtyp_HBW".Vertical_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_HBW".Vertical_Axis.di_Actual_Position <= ("gtyp_HBW".di_PosBelt_Vertical - "gtyp_HBW".di_Offset_Pos_Belt_Vertical + "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_HBW".Vertical_Axis.di_Actual_Position >= ("gtyp_HBW".di_PosBelt_Vertical - "gtyp_HBW".di_Offset_Pos_Belt_Vertical - "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_HBW".Vertical_Axis.x_Position_Reached THEN
	                "gtyp_HBW".Vertical_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_HBW".Vertical_Axis.di_Actual_Position <= ("gtyp_HBW".di_PosBelt_Vertical - "gtyp_HBW".di_Offset_Pos_Belt_Vertical + "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_HBW".Vertical_Axis.di_Actual_Position >= ("gtyp_HBW".di_PosBelt_Vertical - "gtyp_HBW".di_Offset_Pos_Belt_Vertical - "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_HBW".Vertical_Axis.x_Position_Reached THEN
	                "gtyp_HBW".Vertical_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 220;
	            END_IF;
	            
	        220: // Position Cantilever back Belt   
	            "QX_HBW_M4_CantileverBackward_Q8" := TRUE;
	            "QX_HBW_M4_CantileverForward_Q7" := FALSE;
	            
	            IF NOT "IX_HBW_SwitchCantileverFront_I5" AND "IX_HBW_SwitchCantileverBack_I6" THEN
	                "QX_HBW_M4_CantileverBackward_Q8" := FALSE;
	                "QX_HBW_M4_CantileverForward_Q7" := FALSE;
	                #li_StepCase := 230;
	            END_IF;
	            
	        230: // Position vertical+offset/horizontal HBW
	            "gtyp_HBW".Horizontal_Axis.di_Target_Position := #ldi_PosRack_Horizontal;
	            "gtyp_HBW".Horizontal_Axis.x_Start_Positioning := TRUE;
	            "gtyp_HBW".Vertical_Axis.di_Target_Position := #ldi_PosRack_Vertical - "gtyp_HBW".di_Offset_Pos_Rack_Vertical;
	            "gtyp_HBW".Vertical_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_HBW".Horizontal_Axis.di_Actual_Position <= (#ldi_PosRack_Horizontal + "gtyp_HBW".Horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_HBW".Horizontal_Axis.di_Actual_Position >= (#ldi_PosRack_Horizontal - "gtyp_HBW".Horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_HBW".Horizontal_Axis.x_Position_Reached THEN
	                "gtyp_HBW".Horizontal_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_HBW".Vertical_Axis.di_Actual_Position <= (#ldi_PosRack_Vertical - "gtyp_HBW".di_Offset_Pos_Rack_Vertical + "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_HBW".Vertical_Axis.di_Actual_Position >= (#ldi_PosRack_Vertical - "gtyp_HBW".di_Offset_Pos_Rack_Vertical - "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_HBW".Vertical_Axis.x_Position_Reached THEN
	                "gtyp_HBW".Vertical_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_HBW".Horizontal_Axis.di_Actual_Position <= (#ldi_PosRack_Horizontal + "gtyp_HBW".Horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_HBW".Horizontal_Axis.di_Actual_Position >= (#ldi_PosRack_Horizontal - "gtyp_HBW".Horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_HBW".Horizontal_Axis.x_Position_Reached
	                AND ("gtyp_HBW".Vertical_Axis.di_Actual_Position <= (#ldi_PosRack_Vertical - "gtyp_HBW".di_Offset_Pos_Rack_Vertical + "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_HBW".Vertical_Axis.di_Actual_Position >= (#ldi_PosRack_Vertical - "gtyp_HBW".di_Offset_Pos_Rack_Vertical - "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_HBW".Vertical_Axis.x_Position_Reached THEN
	                "gtyp_HBW".Horizontal_Axis.x_Start_Positioning := FALSE;
	                "gtyp_HBW".Vertical_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 240;
	            END_IF;
	            
	        240: // Position Cantilever Forward HBW
	            
	            "QX_HBW_M4_CantileverBackward_Q8" := FALSE;
	            "QX_HBW_M4_CantileverForward_Q7" := TRUE;
	            
	            IF "IX_HBW_SwitchCantileverFront_I5" AND NOT "IX_HBW_SwitchCantileverBack_I6" THEN
	                "QX_HBW_M4_CantileverBackward_Q8" := FALSE;
	                "QX_HBW_M4_CantileverForward_Q7" := FALSE;
	                #li_StepCase := 250;
	            END_IF;
	            
	        250: // Position vertical HBW
	            "gtyp_HBW".Vertical_Axis.di_Target_Position := #ldi_PosRack_Vertical;
	            "gtyp_HBW".Vertical_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_HBW".Vertical_Axis.di_Actual_Position <= (#ldi_PosRack_Vertical + "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_HBW".Vertical_Axis.di_Actual_Position >= (#ldi_PosRack_Vertical - "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_HBW".Vertical_Axis.x_Position_Reached THEN
	                IF #lx_Storage THEN
	                    #li_Return_LDT := RD_SYS_T(#ldt_MQTT);
	                    "gtyp_HBW".History[3].i_code := 300;
	                    "gtyp_HBW".History[3].ldt_ts := DT_TO_LDT(#ldt_MQTT);
	                    "gtyp_HBW".Rack_Workpiece[#li_Counter_Act_Ver, #li_Counter_Act_Hor] := "gtyp_HBW".Workpiece;
	                    "gtyp_HBW".Rack_History[#li_Counter_Act_Ver, #li_Counter_Act_Hor].History := "gtyp_HBW".History;
	                    "gtyp_Interface_Dashboard".Subscribe.State_HBW.x_active := FALSE;
	                ELSE
	                    "gtyp_HBW".Rack_Workpiece[#li_Counter_Act_Ver, #li_Counter_Act_Hor].s_id := '0';
	                END_IF;
	                "gtyp_HBW".Vertical_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 260;
	            END_IF;
	            
	        260: // Position Cantilever Backward HBW
	            
	            "QX_HBW_M4_CantileverBackward_Q8" := TRUE;
	            "QX_HBW_M4_CantileverForward_Q7" := FALSE;
	            
	            IF NOT "IX_HBW_SwitchCantileverFront_I5" AND "IX_HBW_SwitchCantileverBack_I6" THEN
	                "QX_HBW_M4_CantileverBackward_Q8" := FALSE;
	                "QX_HBW_M4_CantileverForward_Q7" := FALSE;
	                #li_StepCase := 0;
	                #lx_Storage := FALSE;
	            END_IF;
	    // Statement section ELSE    
	    ELSE  
	        ;
	    END_CASE;
	    
	    //Reset the information in the high-bay warehouse
	    IF "gtyp_Setup".x_Clean_Rack_HBW THEN
	        FOR #li_Counter_Hor := 1 TO 3 DO
	            FOR #li_Counter_Ver := 1 TO 3 DO
	                "gtyp_HBW".Rack_Workpiece[#li_Counter_Ver, #li_Counter_Hor].s_id := '0';
	                "gtyp_HBW".Rack_Workpiece[#li_Counter_Ver, #li_Counter_Hor].s_state := '';
	                "gtyp_HBW".Rack_Workpiece[#li_Counter_Ver, #li_Counter_Hor].s_type := '';
	                FOR #li_Counter := 1 TO 8 DO
	                    "gtyp_HBW".Rack_History[#li_Counter_Ver, #li_Counter_Hor].History[#li_Counter].i_code := 0;
	                    "gtyp_HBW".Rack_History[#li_Counter_Ver, #li_Counter_Hor].History[#li_Counter].ldt_ts := DT#1990-01-01-00:00:00;
	                END_FOR;
	            END_FOR;
	        END_FOR;
	        "gtyp_Setup".x_Clean_Rack_HBW := FALSE;
	    END_IF;
	    
	    // reload PWM
	    "QW_HBW_PWM_ConveyorBelt_M1"   := "gtyp_HBW"."i_PWM_ConveyorBelt";
	    "QW_HBW_PWM_Cantilever_M4"     := "gtyp_HBW"."i_PWM_Cantilever";
	ELSE
	    FOR #li_Counter_Hor := 1 TO 3 DO
	        FOR #li_Counter_Ver := 1 TO 3 DO
	            IF "gtyp_HBW".Rack_Workpiece[#li_Counter_Ver, #li_Counter_Hor].s_id = '' THEN
	                "gtyp_HBW".Rack_Workpiece[#li_Counter_Ver, #li_Counter_Hor].s_id := '0';
	                "gtyp_HBW".Rack_Workpiece[#li_Counter_Ver, #li_Counter_Hor].s_state := '';
	                "gtyp_HBW".Rack_Workpiece[#li_Counter_Ver, #li_Counter_Hor].s_type := '';
	                FOR #li_Counter := 1 TO 8 DO
	                    "gtyp_HBW".Rack_History[#li_Counter_Ver, #li_Counter_Hor].History[#li_Counter].i_code := 0;
	                    "gtyp_HBW".Rack_History[#li_Counter_Ver, #li_Counter_Hor].History[#li_Counter].ldt_ts := DT#1990-01-01-00:00:00;
	                END_FOR;
	            END_IF;
	        END_FOR;
	    END_FOR;
	    
	    #li_Lights := 1;
	    #lx_Init := TRUE;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "PRG_VGR_Axis_vertical"
TITLE = Program Axis vertical VGR
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
   VAR 
      lx_Init { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lfb_vertical_Axis { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Axis";
   END_VAR


BEGIN
	IF #lx_Init THEN
	    
	    // FB Axis vertical
	    #lfb_vertical_Axis(ini_Axis         := 2,
	                indi_Increment          := "gtyp_VGR".vertical_Axis.di_Increment,
	                inx_Ref_Switch          := "IX_VGR_RefSwitchVerticalAxis_I1",
	                inx_Referencing         := "gtyp_VGR".vertical_Axis.x_Reference,
	                inx_Start_Positioning   := "gtyp_VGR".vertical_Axis.x_Start_Positioning,
	                indi_Target_Position    := "gtyp_VGR".vertical_Axis.di_Target_Position,
	                ini_PWM                 := "gtyp_VGR".vertical_Axis.i_PWM,
	                inouttyp_Config         := "gtyp_VGR".vertical_Axis.Config,
	                inouttyp_Setup          := "gtyp_SetupAxis");
	    
	    "QX_VGR_M1_VerticalAxisUp_Q1"       := #lfb_vertical_Axis.outx_Motor_Neg;
	    "QX_VGR_M1_VerticalAxisDown_Q2"     := #lfb_vertical_Axis.outx_Motor_Pos;
	    "QW_VGR_PWM_Vertical_M1"            := #lfb_vertical_Axis.outi_Motor_PWM;
	    "gtyp_VGR".vertical_Axis.di_Actual_Position:= #lfb_vertical_Axis.outdi_Actual_Position;
	    "gtyp_VGR".vertical_Axis.x_Referenced      := #lfb_vertical_Axis.outx_Referenced;
	    "gtyp_VGR".vertical_Axis.x_Position_Reached:= #lfb_vertical_Axis.outx_Position_Reached;
	ELSE
	    #lx_Init := TRUE;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "PRG_VGR_Axis_horizontal"
TITLE = Program Axis horizontal VGR
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
   VAR 
      lx_Init { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lfb_horizontal_Axis { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Axis";
   END_VAR


BEGIN
	IF #lx_Init THEN
	    
	    // FB Axis horizontal
	    #lfb_horizontal_Axis(ini_Axis       := 1,
	                indi_Increment          := "gtyp_VGR".horizontal_Axis.di_Increment,
	                inx_Ref_Switch          := "IX_VGR_RefSwitchHorizontalAxis_I2",
	                inx_Referencing         := "gtyp_VGR".horizontal_Axis.x_Reference,
	                inx_Start_Positioning   := "gtyp_VGR".horizontal_Axis.x_Start_Positioning,
	                indi_Target_Position    := "gtyp_VGR".horizontal_Axis.di_Target_Position,
	                ini_PWM                 := "gtyp_VGR".horizontal_Axis.i_PWM,
	                inouttyp_Config         := "gtyp_VGR".horizontal_Axis.Config,
	                inouttyp_Setup          := "gtyp_SetupAxis");
	    
	    "QX_VGR_M2_HorizontalAxisForward_Q4"    := #lfb_horizontal_Axis.outx_Motor_Pos;
	    "QX_VGR_M2_HorizontalAxisBackward_Q3"   := #lfb_horizontal_Axis.outx_Motor_Neg;
	    "QW_VGR_PWM_Horizontal_M2"              := #lfb_horizontal_Axis.outi_Motor_PWM;
	    "gtyp_VGR".horizontal_Axis.di_Actual_Position    := #lfb_horizontal_Axis.outdi_Actual_Position;
	    "gtyp_VGR".horizontal_Axis.x_Referenced          := #lfb_horizontal_Axis.outx_Referenced;
	    "gtyp_VGR".horizontal_Axis.x_Position_Reached    := #lfb_horizontal_Axis.outx_Position_Reached;
	ELSE
	    #lx_Init := TRUE;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "PRG_SSC_Axis_Horizontal"
TITLE = Program Axis horizontal SSC
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
   VAR 
      lx_Init { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lfb_Horizontal_Axis { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Axis";
   END_VAR


BEGIN
	IF #lx_Init THEN
	    
	    // FB Axis horizontal
	    #lfb_Horizontal_Axis(   ini_Axis                := 4,
	                            indi_Increment          := "gtyp_SSC".Horizontal_Axis.di_Increment,
	                            inx_Ref_Switch          := "IX_SSC_RefSwitchHorizontalAxis_I2",
	                            inx_Referencing         := "gtyp_SSC".Horizontal_Axis.x_Reference,
	                            inx_Start_Positioning   := "gtyp_SSC".Horizontal_Axis.x_Start_Positioning,
	                            indi_Target_Position    := "gtyp_SSC".Horizontal_Axis.di_Target_Position,
	                            ini_PWM               := "gtyp_SSC".Horizontal_Axis.i_PWM,
	                            inouttyp_Config         := "gtyp_SSC".Horizontal_Axis.Config,
	                            inouttyp_Setup          := "gtyp_SetupAxis");
	       
	    "QX_SSC_M2_HorizontalAxisCounterclockwise_Q4"      := #lfb_Horizontal_Axis.outx_Motor_Neg;
	    "QX_SSC_M2_HorizontalAxisClockwise_Q3"             := #lfb_Horizontal_Axis.outx_Motor_Pos;
	    "QW_SSC_PWM_Horizontal_M2"                         := #lfb_Horizontal_Axis.outi_Motor_PWM;
	    "gtyp_SSC".Horizontal_Axis.di_Actual_Position   := #lfb_Horizontal_Axis.outdi_Actual_Position;
	    "gtyp_SSC".Horizontal_Axis.x_Referenced         := #lfb_Horizontal_Axis.outx_Referenced;
	    "gtyp_SSC".Horizontal_Axis.x_Position_Reached   := #lfb_Horizontal_Axis.outx_Position_Reached;
	ELSE
	    #lx_Init := TRUE;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "PRG_SLD_Ablauf"
TITLE = Program Ablauf SLD
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
   VAR 
      lx_Init { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Start_TON_Wait { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Time_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lt_TON_Wait { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;
      lx_Start_TON_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ldt_MQTT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Date_And_Time;
      li_Return_LDT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      li_Lights { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      li_Lights_old { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      lw_ColorValueMin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
      li_CounterActual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      lx_White { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Blue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Red { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      li_StepCase { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ls_Color { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;
      lfb_TOF_ConveyerBelt_Out {InstructionName := 'TOF_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TOF_TIME;
      lfb_TON_Wait {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      lfb_TON_Error {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      lfb_TON_State {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      lfb_F_Trig_Counter {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;
      lfb_R_Trig_Counter {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
   END_VAR


BEGIN
	IF #lx_Init THEN
	    
	    // Restart after set Positioning
	    IF "gtyp_Setup".x_Color_Sensor_Calibration THEN
	        #li_StepCase := 0;
	    END_IF;
	    
	    // wait time state
	    #lfb_TON_State(IN := NOT #lx_Start_TON_State,
	                    PT := T#2s);
	    
	    // state of the SLD cyclically transmitted to the cloud
	    IF (#lfb_TON_State.Q OR (#li_Lights <> #li_Lights_old)) AND NOT #lx_Start_TON_State THEN
	        #li_Lights_old := #li_Lights;
	        #lx_Start_TON_State := TRUE;
	        #li_Return_LDT := RD_SYS_T(#ldt_MQTT);
	        "gtyp_Interface_Dashboard".Subscribe.State_SLD.ldt_ts := DT_TO_LDT(#ldt_MQTT);
	        "gtyp_Interface_Dashboard".Subscribe.State_SLD.i_code := #li_Lights;
	        "gtyp_Interface_Dashboard".Subscribe.State_SLD.s_description := '';
	        "gtyp_Interface_Dashboard".Subscribe.State_SLD.s_station := 'sld';
	        "gtyp_Interface_Dashboard".Subscribe.State_SLD.s_target := '';
	    END_IF;
	    
	    // restart wait time state
	    IF NOT #lfb_TON_State.Q AND #lx_Start_TON_State THEN
	        #lx_Start_TON_State := FALSE;
	    END_IF;
	    
	    // FB TON Wait
	    #lfb_TON_Wait(IN := #lx_Start_TON_Wait,
	                     PT := #lt_TON_Wait);
	    
	    // runtime monitoring error
	    #lfb_TON_Error(IN:= #lx_Time_Error,
	                   PT:= T#30s);
	    
	    // rising edge pulse counter
	    #lfb_R_Trig_Counter(CLK:= "IX_SLD_PulseCounter_I1");
	    
	    // falling edge pulse counter
	    #lfb_F_Trig_Counter(CLK := "IX_SLD_PulseCounter_I1");
	    
	    // step chain SLD
	    CASE #li_StepCase OF
	            
	        0:  // Init
	            #lx_Start_TON_Wait := FALSE;
	            #lx_Time_Error := FALSE;
	            #li_Lights := 1;
	            
	            IF NOT "gtyp_SLD".x_Error THEN
	                #li_StepCase := 10;
	            END_IF;
	            
	        10: // turn-on Compressor and wait sequence 
	            #li_Lights := 2;
	            "QX_SLD_Compressor_Q2" := TRUE;
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#1000ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 20;
	            END_IF;
	            
	        20:  // reset Ejectors
	            "QX_SLD_ValveFirstEjectorWhite_Q3"  := FALSE;
	            "QX_SLD_ValveSecondEjectorRed_Q4"   := FALSE;
	            "QX_SLD_ValveThirdEjectorBlue_Q5"   := FALSE;
	            "QX_SLD_M1_ConveyorBelt_Q1"         := FALSE;
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#2000ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 30;
	            END_IF;
	            
	        30: // turn-off Compressor 
	            
	            "QX_SLD_Compressor_Q2" := FALSE;
	            
	            #li_StepCase := 40;
	            
	        40: // start belt if Light barrier I2 active
	            
	            #li_Lights := 1;
	            IF NOT "IX_SLD_LightBarrierInlet_I2" THEN
	                "gtyp_Interface_Dashboard".Subscribe.State_SLD.x_active := TRUE;
	                #li_Lights := 2;
	                "QX_SLD_Compressor_Q2"      := TRUE;
	                "QX_SLD_M1_ConveyorBelt_Q1" := TRUE;
	                #lw_ColorValueMin           := 40000;
	                #li_CounterActual := 0;
	                #lx_Blue := FALSE;
	                #lx_Red := FALSE;
	                #lx_White := FALSE;
	                #li_StepCase := 50;
	            END_IF;
	            
	        50: // take the min Value of the Color sensor
	            IF #lw_ColorValueMin > "IW_SLD_ColorSensor_A4" THEN
	                #lw_ColorValueMin := "IW_SLD_ColorSensor_A4";
	            END_IF;
	            
	            #lx_Time_Error := TRUE;
	            
	            // Stop when light barrier I3 on 
	            IF NOT "IX_SLD_LightBarrierBehindColorSensor_I3" THEN
	                #lx_Time_Error  := FALSE;
	                #li_StepCase    := 60;
	            END_IF;
	            
	            // runtime error
	            IF #lfb_TON_Error.Q THEN
	                #li_Lights                  := 4;
	                #lx_Time_Error              := FALSE;
	                "QX_SLD_Compressor_Q2"      := FALSE;
	                "QX_SLD_M1_ConveyorBelt_Q1" := FALSE;
	                "gtyp_Interface_Dashboard".Subscribe.State_SLD.x_active := FALSE;
	                "gtyp_SLD".x_Error          := TRUE;
	                #li_StepCase                := 0;
	            END_IF;
	            
	        60: // analyze color
	            
	            IF #lw_ColorValueMin >= "gtyp_SLD".w_Threshold_Red_Blue THEN
	                #lx_Blue := TRUE;
	            ELSIF #lw_ColorValueMin <= "gtyp_SLD".w_Threshold_White_Red THEN
	                #lx_White := TRUE;
	            ELSIF #lw_ColorValueMin > "gtyp_SLD".w_Threshold_White_Red AND #lw_ColorValueMin < "gtyp_SLD".w_Threshold_Red_Blue THEN
	                #lx_Red := TRUE;
	            END_IF;
	            
	            // actual counter
	            IF #lfb_R_Trig_Counter.Q OR #lfb_F_Trig_Counter.Q THEN
	                #li_CounterActual := #li_CounterActual + 1;
	            END_IF;
	            
	            // Reached counter value and color set Ejector
	            IF (#li_CounterActual = "gtyp_SLD".i_CounterValue_Blue) AND #lx_Blue THEN
	                "QX_SLD_ValveThirdEjectorBlue_Q5" := TRUE;
	                #li_Return_LDT := RD_SYS_T(#ldt_MQTT);
	                "gtyp_SLD".Workpiece.s_state := 'PROCESSED';
	                "gtyp_SLD".History[7].i_code := 700;
	                "gtyp_SLD".History[7].ldt_ts := DT_TO_LDT(#ldt_MQTT);
	                #li_StepCase := 70;
	            ELSIF (#li_CounterActual = "gtyp_SLD".i_CounterValue_White) AND #lx_White THEN
	                "QX_SLD_ValveFirstEjectorWhite_Q3" := TRUE;
	                #li_Return_LDT := RD_SYS_T(#ldt_MQTT);
	                "gtyp_SLD".Workpiece.s_state := 'PROCESSED';
	                "gtyp_SLD".History[7].i_code := 700;
	                "gtyp_SLD".History[7].ldt_ts := DT_TO_LDT(#ldt_MQTT);
	                #li_StepCase := 70;
	            ELSIF (#li_CounterActual = "gtyp_SLD".i_CounterValue_Red) AND #lx_Red THEN
	                "QX_SLD_ValveSecondEjectorRed_Q4" := TRUE;
	                #li_Return_LDT := RD_SYS_T(#ldt_MQTT);
	                "gtyp_SLD".Workpiece.s_state := 'PROCESSED';
	                "gtyp_SLD".History[7].i_code := 700;
	                "gtyp_SLD".History[7].ldt_ts := DT_TO_LDT(#ldt_MQTT);
	                #li_StepCase := 70;
	            ELSIF (#li_CounterActual = 80) THEN
	                #li_Lights := 4;
	                "gtyp_SLD".x_Error := TRUE;
	                #li_StepCase := 70;
	            END_IF;
	            
	        70: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                "QX_SLD_ValveThirdEjectorBlue_Q5" := FALSE;
	                "QX_SLD_ValveFirstEjectorWhite_Q3" := FALSE;
	                "QX_SLD_ValveSecondEjectorRed_Q4" := FALSE;
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 80;
	            END_IF;
	            
	        80: // wait sequence
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#2000ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                "QX_SLD_Compressor_Q2" := FALSE;
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 90;
	            END_IF;
	            
	        90: // Stop belt
	            "QX_SLD_M1_ConveyorBelt_Q1"    := FALSE;
	            #li_StepCase := 40;
	        // Statement section ELSE
	        ELSE  
	            ;
	    END_CASE;
	 
	ELSE
	    #li_Lights := 1;
	    #lx_Init := TRUE;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "PRG_SSC_Axis_Vertical"
TITLE = Program Axis vertical SSC
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
   VAR 
      lx_Init { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lfb_Vertical_Axis { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Axis";
   END_VAR


BEGIN
	IF #lx_Init THEN
	    
	    // FB Axis vertical
	    #lfb_Vertical_Axis( ini_Axis                := 5,
	                        indi_Increment          := "gtyp_SSC".Vertical_Axis.di_Increment,
	                        inx_Ref_Switch          := "IX_SSC_RefSwitchVerticalAxis_I1",
	                        inx_Referencing         := "gtyp_SSC".Vertical_Axis.x_Reference,
	                        inx_Start_Positioning   := "gtyp_SSC".Vertical_Axis.x_Start_Positioning,
	                        indi_Target_Position    := "gtyp_SSC".Vertical_Axis.di_Target_Position,
	                        ini_PWM               := "gtyp_SSC".Vertical_Axis.i_PWM,
	                        inouttyp_Config         := "gtyp_SSC".Vertical_Axis.Config,
	                        inouttyp_Setup          := "gtyp_SetupAxis");
	    
	    "QX_SSC_M1_VerticalAxisUp_Q1"                    := #lfb_Vertical_Axis.outx_Motor_Pos;
	    "QX_SSC_M1_VerticalAxisDown_Q2"                  := #lfb_Vertical_Axis.outx_Motor_Neg;
	    "QW_SSC_PWM_Vertical_M1"                         := #lfb_Vertical_Axis.outi_Motor_PWM;
	    "gtyp_SSC".Vertical_Axis.di_Actual_Position   := #lfb_Vertical_Axis.outdi_Actual_Position;
	    "gtyp_SSC".Vertical_Axis.x_Referenced         := #lfb_Vertical_Axis.outx_Referenced;
	    "gtyp_SSC".Vertical_Axis.x_Position_Reached   := #lfb_Vertical_Axis.outx_Position_Reached;
	ELSE
	    #lx_Init := TRUE;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "PRG_HBW_Set_Positioning"
TITLE = Program Set Positioning HBW
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
   VAR 
      lx_Init { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Start_TON_Wait { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Start_Positioning_m { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lt_TON_Wait { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;
      li_Counter_Hor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      li_Counter_Ver { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      li_Counter_Act_Hor { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      li_Counter_Act_Ver { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      li_Counter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      li_StepCase { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ldi_Pos_Horizontal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      ldi_Pos_Vertical { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      ldi_Offset_Vertical { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      lfb_R_Trig_Deaktivate {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      lfb_TON_Wait {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
   END_VAR


BEGIN
	IF #lx_Init THEN
	    
	    // FB TON Wait
	    #lfb_TON_Wait(IN := #lx_Start_TON_Wait,
	                  PT := #lt_TON_Wait);
	    
	    #lfb_R_Trig_Deaktivate(CLK:= NOT "gtyp_Setup".x_Set_Pos_Activ
	                           OR NOT (("gtyp_Setup".i_Pos_Selection > 20)
	                           AND ("gtyp_Setup".i_Pos_Selection < 41)));
	    // Deaktivate step 110   
	    IF #lfb_R_Trig_Deaktivate.Q THEN
	        "gtyp_HBW".Horizontal_Axis.x_Start_Positioning := FALSE;
	        "gtyp_HBW".Vertical_Axis.x_Start_Positioning := FALSE;
	        "gtyp_HBW".Horizontal_Axis.x_Reference := FALSE;
	        "gtyp_HBW".Vertical_Axis.x_Reference := FALSE;
	        "gtyp_Setup".x_Start_Positioning := FALSE;
	        "gtyp_Setup".x_Final_Positioning := FALSE;
	        "gtyp_Setup".x_Home_Positioning := FALSE;
	        "gtyp_Setup".x_Start_Offset := FALSE;
	        "QX_HBW_M4_CantileverBackward_Q8" := FALSE;
	        "QX_HBW_M4_CantileverForward_Q7" := FALSE;
	        IF (#li_StepCase > 10) THEN
	            #li_StepCase := 110;
	        END_IF;
	    END_IF;
	    
	    // step chain HBW
	    CASE #li_StepCase OF
	            
	        0:  // init
	            #lx_Start_TON_Wait := FALSE;
	            #li_StepCase := 10;
	            
	        10:  // Set Positioning activ?
	            IF "gtyp_Setup".x_Set_Pos_Activ
	                AND (("gtyp_Setup".i_Pos_Selection > 20)
	                AND ("gtyp_Setup".i_Pos_Selection < 41)) THEN
	                
	                // Deciding which Position
	                // Position - Belt
	                IF "gtyp_Setup".i_Pos_Selection = 21 THEN
	                    #ldi_Pos_Horizontal := "gtyp_HBW".di_PosBelt_Horizontal;
	                    #ldi_Pos_Vertical := "gtyp_HBW".di_PosBelt_Vertical;
	                    #ldi_Offset_Vertical := "gtyp_HBW".di_Offset_Pos_Belt_Vertical;
	                    // Position - A1 
	                ELSIF "gtyp_Setup".i_Pos_Selection = 22 THEN
	                    #ldi_Pos_Horizontal := "gtyp_HBW".di_PosRack_A1_Horizontal;
	                    #ldi_Pos_Vertical := "gtyp_HBW".di_PosRack_A1_Vertical;
	                    #ldi_Offset_Vertical := "gtyp_HBW".di_Offset_Pos_Rack_Vertical;
	                    // Position - B2 
	                ELSIF "gtyp_Setup".i_Pos_Selection = 23 THEN
	                    #ldi_Pos_Horizontal := "gtyp_HBW".di_PosRack_B2_Horizontal;
	                    #ldi_Pos_Vertical := "gtyp_HBW".di_PosRack_B2_Vertical;
	                    #ldi_Offset_Vertical := "gtyp_HBW".di_Offset_Pos_Rack_Vertical;
	                    // Position - C3 
	                ELSIF "gtyp_Setup".i_Pos_Selection = 24 THEN
	                    #ldi_Pos_Horizontal := "gtyp_HBW".di_PosRack_C3_Horizontal;
	                    #ldi_Pos_Vertical := "gtyp_HBW".di_PosRack_C3_Vertical;
	                    #ldi_Offset_Vertical := "gtyp_HBW".di_Offset_Pos_Rack_Vertical;
	                END_IF;
	                
	                "gtyp_HBW".Horizontal_Axis.x_Start_Positioning  := FALSE;
	                "gtyp_HBW".Vertical_Axis.x_Start_Positioning    := FALSE;
	                "gtyp_HBW".Horizontal_Axis.x_Reference          := FALSE;
	                "gtyp_HBW".Vertical_Axis.x_Reference            := FALSE;
	                "gtyp_Setup".x_Start_Positioning            := FALSE;
	                "gtyp_Setup".x_Final_Positioning            := FALSE;
	                "gtyp_Setup".x_Home_Positioning             := FALSE;
	                "gtyp_Setup".x_Start_Offset                 := FALSE;
	                "QX_HBW_M4_CantileverBackward_Q8"               := FALSE;
	                "QX_HBW_M4_CantileverForward_Q7"                := FALSE;
	                #li_StepCase                                    := 20;
	            END_IF;
	            
	        20: //homing vertical/horizontal axis
	            
	            "gtyp_HBW".Horizontal_Axis.x_Reference := TRUE;
	            "gtyp_HBW".Vertical_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_HBW".Horizontal_Axis.x_Referenced AND NOT "gtyp_HBW".Vertical_Axis.x_Referenced THEN
	                #li_StepCase := 30;
	            END_IF;
	            
	        30: // homed vertical/horizontal axis
	            IF "gtyp_HBW".Horizontal_Axis.x_Referenced THEN
	                "gtyp_HBW".Horizontal_Axis.x_Reference := FALSE;
	            END_IF;
	            IF "gtyp_HBW".Vertical_Axis.x_Referenced THEN
	                "gtyp_HBW".Vertical_Axis.x_Reference := FALSE;
	            END_IF;
	            
	            IF "gtyp_HBW".Horizontal_Axis.x_Referenced AND "gtyp_HBW".Vertical_Axis.x_Referenced THEN
	                "gtyp_HBW".Horizontal_Axis.x_Reference := FALSE;
	                "gtyp_HBW".Vertical_Axis.x_Reference := FALSE;
	                #li_StepCase := 40;
	            END_IF;
	            
	        40: // Start Positioning Step next
	            IF "gtyp_Setup".x_Start_Positioning OR #lx_Start_Positioning_m THEN
	                #lx_Start_Positioning_m := FALSE;
	                #li_StepCase := 50;
	            END_IF;
	            
	        50: // Position vertical/horizontal HBW
	            "gtyp_HBW".Horizontal_Axis.di_Target_Position   := #ldi_Pos_Horizontal;
	            "gtyp_HBW".Horizontal_Axis.x_Start_Positioning  := TRUE;
	            "gtyp_HBW".Vertical_Axis.di_Target_Position     := #ldi_Pos_Vertical;
	            "gtyp_HBW".Vertical_Axis.x_Start_Positioning    := TRUE;
	            
	            IF ("gtyp_HBW".Horizontal_Axis.di_Actual_Position <= (#ldi_Pos_Horizontal + "gtyp_HBW".Horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_HBW".Horizontal_Axis.di_Actual_Position >= (#ldi_Pos_Horizontal - "gtyp_HBW".Horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_HBW".Horizontal_Axis.x_Position_Reached THEN
	                "gtyp_HBW".Horizontal_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_HBW".Vertical_Axis.di_Actual_Position <= (#ldi_Pos_Vertical + "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_HBW".Vertical_Axis.di_Actual_Position >= (#ldi_Pos_Vertical - "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_HBW".Vertical_Axis.x_Position_Reached THEN
	                "gtyp_HBW".Vertical_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_HBW".Horizontal_Axis.di_Actual_Position <= (#ldi_Pos_Horizontal + "gtyp_HBW".Horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_HBW".Horizontal_Axis.di_Actual_Position >= (#ldi_Pos_Horizontal - "gtyp_HBW".Horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_HBW".Horizontal_Axis.x_Position_Reached
	                AND ("gtyp_HBW".Vertical_Axis.di_Actual_Position <= (#ldi_Pos_Vertical + "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_HBW".Vertical_Axis.di_Actual_Position >= (#ldi_Pos_Vertical - "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_HBW".Vertical_Axis.x_Position_Reached THEN
	                "gtyp_HBW".Horizontal_Axis.x_Start_Positioning  := FALSE;
	                "gtyp_HBW".Vertical_Axis.x_Start_Positioning    := FALSE;
	                "gtyp_Setup".x_Start_Positioning          := FALSE;
	                #li_StepCase := 60;
	            END_IF;
	            
	        60: // Deciding which doing
	            
	            // Start new Positioning
	            IF "gtyp_Setup".x_Start_Positioning THEN
	                #lx_Start_Positioning_m := TRUE;
	                #li_StepCase := 10;
	            // Start Final Positioning
	            ELSIF "gtyp_Setup".x_Final_Positioning THEN
	                #li_StepCase := 70;
	            // Deaktivate Set Positioning
	            ELSIF #lfb_R_Trig_Deaktivate.Q OR "gtyp_Setup".x_Home_Positioning THEN
	                "gtyp_Setup".x_Home_Positioning := FALSE;
	                #li_StepCase := 110;
	            END_IF;
	            
	        70: // Final Positioning - Cantilever Forward
	            
	            "QX_HBW_M4_CantileverBackward_Q8" := FALSE;
	            "QX_HBW_M4_CantileverForward_Q7" := TRUE;
	            
	            IF "IX_HBW_SwitchCantileverFront_I5" AND NOT "IX_HBW_SwitchCantileverBack_I6" THEN
	                "QX_HBW_M4_CantileverBackward_Q8" := FALSE;
	                "QX_HBW_M4_CantileverForward_Q7" := FALSE;
	                "gtyp_Setup".x_Final_Positioning := FALSE;
	                #li_StepCase := 80;
	            END_IF;
	            
	        80: // Deciding which doing
	            
	            // Start new Positioning
	            IF "gtyp_Setup".x_Start_Positioning THEN
	                #lx_Start_Positioning_m := TRUE;
	                #li_StepCase := 110;
	                // Start Final Positioning
	            ELSIF "gtyp_Setup".x_Final_Positioning THEN
	                #li_StepCase := 70;
	                // Start Final Positioning
	            ELSIF "gtyp_Setup".x_Start_Offset THEN
	                #li_StepCase := 90;
	                // Deaktivate Set Positioning
	            ELSIF #lfb_R_Trig_Deaktivate.Q OR "gtyp_Setup".x_Home_Positioning THEN
	                "gtyp_Setup".x_Home_Positioning := FALSE;
	                #li_StepCase := 110;
	            END_IF;
	            
	        90: // Position vertical+offset HBW
	            "gtyp_HBW".Vertical_Axis.di_Target_Position := #ldi_Pos_Vertical - #ldi_Offset_Vertical;
	            "gtyp_HBW".Vertical_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_HBW".Vertical_Axis.di_Actual_Position <= (#ldi_Pos_Vertical - #ldi_Offset_Vertical + "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_HBW".Vertical_Axis.di_Actual_Position >= (#ldi_Pos_Vertical - #ldi_Offset_Vertical - "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_HBW".Vertical_Axis.x_Position_Reached THEN
	                "gtyp_HBW".Vertical_Axis.x_Start_Positioning := FALSE;
	                "gtyp_Setup".x_Start_Offset            := FALSE;
	                #li_StepCase := 100;
	            END_IF;
	            
	        100: // Deciding which doing
	            
	            // Start new Positioning
	            IF "gtyp_Setup".x_Start_Positioning THEN
	                #lx_Start_Positioning_m := TRUE;
	                #li_StepCase := 110;
	                // Start Final Positioning
	            ELSIF "gtyp_Setup".x_Final_Positioning THEN
	                #lx_Start_Positioning_m := TRUE;
	                #li_StepCase := 110;
	                // Start Final Positioning
	            ELSIF "gtyp_Setup".x_Start_Offset THEN
	                #li_StepCase := 110;
	                // Deaktivate Set Positioning
	            ELSIF #lfb_R_Trig_Deaktivate.Q OR "gtyp_Setup".x_Home_Positioning THEN
	                "gtyp_Setup".x_Home_Positioning := FALSE;
	                #li_StepCase := 110;
	            END_IF;
	            
	        110: // Position vertical HBW
	            "gtyp_HBW".Vertical_Axis.di_Target_Position := #ldi_Pos_Vertical;
	            "gtyp_HBW".Vertical_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_HBW".Vertical_Axis.di_Actual_Position <= (#ldi_Pos_Vertical + "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_HBW".Vertical_Axis.di_Actual_Position >= (#ldi_Pos_Vertical - "gtyp_HBW".Vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_HBW".Vertical_Axis.x_Position_Reached THEN
	                "gtyp_HBW".Vertical_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 120;
	            END_IF;
	            
	        120: // Position vertical Back HBW
	            
	            "QX_HBW_M4_CantileverBackward_Q8" := TRUE;
	            "QX_HBW_M4_CantileverForward_Q7" := FALSE;
	            
	            IF NOT "IX_HBW_SwitchCantileverFront_I5" AND "IX_HBW_SwitchCantileverBack_I6" THEN
	                "QX_HBW_M4_CantileverBackward_Q8" := FALSE;
	                "QX_HBW_M4_CantileverForward_Q7" := FALSE;
	                #li_StepCase := 130;
	            END_IF;
	            
	        130: // homing vertical/horizontal axis
	            
	            "gtyp_HBW".Horizontal_Axis.x_Reference := TRUE;
	            "gtyp_HBW".Vertical_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_HBW".Horizontal_Axis.x_Referenced AND NOT "gtyp_HBW".Vertical_Axis.x_Referenced THEN
	                #li_StepCase := 140;
	            END_IF;
	            
	        140: //homed vertical/horizontal axis
	            IF "gtyp_HBW".Horizontal_Axis.x_Referenced THEN
	                "gtyp_HBW".Horizontal_Axis.x_Reference := FALSE;
	            END_IF;
	            IF "gtyp_HBW".Vertical_Axis.x_Referenced THEN
	                "gtyp_HBW".Vertical_Axis.x_Reference := FALSE;
	            END_IF;
	            
	            IF "gtyp_HBW".Horizontal_Axis.x_Referenced AND "gtyp_HBW".Vertical_Axis.x_Referenced THEN
	                "gtyp_HBW".Horizontal_Axis.x_Reference := FALSE;
	                "gtyp_HBW".Vertical_Axis.x_Reference := FALSE;
	                #li_StepCase := 0;
	            END_IF;
	            
	    // Statement section ELSE    
	    ELSE  
	        ;
	    END_CASE;
	    
	    IF (("gtyp_Setup".i_Pos_Selection > 20)
	        AND ("gtyp_Setup".i_Pos_Selection < 41)) THEN
	        // Reload Pos Value
	        "gtyp_Setup".di_Pos_Horizontal := #ldi_Pos_Horizontal;
	        "gtyp_Setup".di_Pos_Vertical := #ldi_Pos_Vertical;
	        "gtyp_Setup".di_Pos_Rotate := 0;
	    END_IF;
	ELSE
	    #lx_Init := TRUE;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "PRG_Order"
TITLE = Program Order
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
   VAR 
      lx_Init { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      li_StepCase { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      lldt_ts_old { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LDT;
      ldt_MQTT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Date_And_Time;
      li_Return_LDT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      lfb_TON_Wait {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      lx_Start_TON_Wait { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR


BEGIN
	IF #lx_Init THEN
	    #lfb_TON_Wait(IN:= #lx_Start_TON_Wait,PT:= T#20s);
	    
	    // step chain order
	    CASE #li_StepCase OF
	            
	        0:  // init
	            #lx_Start_TON_Wait := FALSE;
	            #li_StepCase := 10;
	            
	        10: // check whether order button has been pressed (time stamp changes)
	            IF ("gtyp_Interface_Dashboard".Publish.OrderWorkpieceButton.ldt_ts > #lldt_ts_old) THEN
	                #li_Return_LDT := RD_SYS_T(#ldt_MQTT);
	                "gtyp_Interface_Dashboard".Subscribe.State_Order.ldt_ts := DT_TO_LDT(#ldt_MQTT);
	                "gtyp_Interface_Dashboard".Subscribe.State_Order.s_state := 'ORDERED';
	                "gtyp_VGR".s_HBW_Outsource_Typ := "gtyp_Interface_Dashboard".Publish.OrderWorkpieceButton.s_type;
	                "gtyp_Interface_Dashboard".Subscribe.State_Order.s_type := "gtyp_VGR".s_HBW_Outsource_Typ;
	                IF "gtyp_VGR".x_Ready_For_Outsource THEN
	                    #lldt_ts_old := "gtyp_Interface_Dashboard".Publish.OrderWorkpieceButton.ldt_ts;
	                    "gtyp_VGR".x_HBW_Outsource := TRUE;
	                    #li_StepCase := 20;
	                END_IF;
	            END_IF;
	                
	        20: // delete
	            IF "gtyp_VGR".x_HBW_PickedUp OR NOT "gtyp_VGR".x_HBW_Outsource THEN
	                "gtyp_VGR".x_HBW_Outsource := FALSE;
	                "gtyp_VGR".s_HBW_Outsource_Typ := '';
	                #li_StepCase := 0;
	            END_IF;
	            
	    // Statement section ELSE
	    ELSE  
	                ;
	    END_CASE;
	 
	ELSE
	    #lx_Init    := TRUE;
	    #lldt_ts_old:= LDT#1970-01-01-00:00:00;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "PRG_DSI_Status"
TITLE = Program Status DSI
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
   VAR 
      lx_Init { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Start { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      li_StepCase { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ldt_MQTT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Date_And_Time;
      li_Return_LDT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      lfb_R_Trig_Storage {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      lfb_F_Trig_Storage {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;
      lfb_TON_Status {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      lx_StartStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lfb_TON_Schritt {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      lx_StartTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR


BEGIN
	IF #lx_Init THEN
	    
	    // wait time state
	    #lfb_TON_Status(IN := NOT #lx_StartStatus,
	                    PT := T#2s);
	    
	    // rising/falling edge light barrier DSI
	    #lfb_R_Trig_Storage(CLK := NOT "IX_SSC_LightBarrierStorage_I3");
	    #lfb_F_Trig_Storage(CLK := NOT "IX_SSC_LightBarrierStorage_I3");
	    
	    // state of the DSI transmitted to the cloud
	    IF (#lfb_TON_Status.Q OR #lfb_R_Trig_Storage.Q OR #lfb_F_Trig_Storage.Q) AND NOT #lx_StartStatus THEN
	        #lx_StartStatus := TRUE;
	        #li_Return_LDT := RD_SYS_T(#ldt_MQTT);
	        IF NOT "IX_SSC_LightBarrierStorage_I3" THEN
	            "gtyp_Interface_Dashboard".Subscribe.State_DSI.i_code := 0;
	            "gtyp_Interface_Dashboard".Subscribe.State_DSI.x_active := TRUE;
	        ELSE
	            "gtyp_Interface_Dashboard".Subscribe.State_DSI.i_code := 1;
	            IF #lfb_F_Trig_Storage.Q THEN
	                "gtyp_Interface_Dashboard".Subscribe.State_DSI.x_active := FALSE;
	            END_IF;
	        END_IF;
	        "gtyp_Interface_Dashboard".Subscribe.State_DSI.ldt_ts := DT_TO_LDT(#ldt_MQTT);
	        "gtyp_Interface_Dashboard".Subscribe.State_DSI.s_station := 'dsi';
	        "gtyp_Interface_Dashboard".Subscribe.State_DSI.s_target := '';
	        "gtyp_Interface_Dashboard".Subscribe.State_DSI.s_description := '';
	    END_IF;
	    
	    IF NOT #lfb_TON_Status.Q AND #lx_StartStatus THEN
	        #lx_StartStatus := FALSE;
	    END_IF;
	ELSE
	    #lx_Init := TRUE;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "PRG_MPO_Ablauf"
TITLE = Program Ablauf MPO
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
   VAR 
      lx_Init { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Start_TON_Wait { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Time_Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lt_TON_Wait { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;
      lx_Start_TON_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ldt_MQTT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Date_And_Time;
      li_Return_LDT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      li_StepCase { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      li_Lights { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      li_Lights_old { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      li_Counter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      lfb_blinker { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_Blinker";
      lfb_TOF_ConveyerBelt_Out {InstructionName := 'TOF_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TOF_TIME;
      lfb_TON_Wait {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      lfb_TON_Error {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      lfb_TON_State {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      lfb_F_Trig_ConveyerBelt {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;
   END_VAR


BEGIN
	IF #lx_Init THEN
	    
	    // wait time state
	    #lfb_TON_State(IN := NOT #lx_Start_TON_State,
	                    PT := T#2s);
	    
	    // runtime monitoring error
	    #lfb_TON_Error(IN := #lx_Time_Error,
	                   PT := T#30s);
	    
	    // state of the MPO cyclically transmitted to the cloud
	    IF (#lfb_TON_State.Q OR (#li_Lights <> #li_Lights_old)) AND NOT #lx_Start_TON_State THEN
	        #li_Lights_old := #li_Lights;
	        #lx_Start_TON_State := TRUE;
	        #li_Return_LDT := RD_SYS_T(#ldt_MQTT);
	        "gtyp_Interface_Dashboard".Subscribe.State_MPO.ldt_ts        := DT_TO_LDT(#ldt_MQTT);
	        "gtyp_Interface_Dashboard".Subscribe.State_MPO.i_code        := #li_Lights;
	        "gtyp_Interface_Dashboard".Subscribe.State_MPO.s_description := '';
	        "gtyp_Interface_Dashboard".Subscribe.State_MPO.s_station     := 'mpo';
	        "gtyp_Interface_Dashboard".Subscribe.State_MPO.s_target      := '';
	    END_IF;
	    
	    // restart wait time state
	    IF NOT #lfb_TON_State.Q AND #lx_Start_TON_State THEN
	        #lx_Start_TON_State := FALSE;
	    END_IF;
	    
	    // FB TON Wait
	    #lfb_TON_Wait(IN := #lx_Start_TON_Wait,
	                    PT := #lt_TON_Wait);
	      
	   // falling edge light barrier end of Conveyor Belt
	   #lfb_F_Trig_ConveyerBelt(CLK := NOT "IX_MPO_LightBarrierEndOfConBelt_I3");
	    
	    //Run-on time Conveyer Belt
	   #lfb_TOF_ConveyerBelt_Out(IN:= #lfb_F_Trig_ConveyerBelt.Q,
	                             PT:= T#5000ms);
	   
	    // FB blinker intervall 1s
	    #lfb_blinker(int_periodendauer:= T#1000ms);
	    
	    // step chain HBW
	    CASE #li_StepCase OF
	            
	        0:  // init
	            #lx_Start_TON_Wait := FALSE;
	            #lx_Time_Error := FALSE;
	            
	            IF NOT "gtyp_MPO".x_Error THEN
	                #li_StepCase := 10;
	            END_IF;
	            
	        10: // turn-on Compressor and turn off oven light 
	            #li_Lights := 2;
	            "QX_MPO_LightOven_Q9"   := FALSE;
	            "QX_MPO_Compressor_Q10" := TRUE;
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 20;
	            END_IF;
	            
	        20:  // Open oven door 
	            "QX_MPO_ValveOvenDoor_Q13" := TRUE;
	            "QX_MPO_ValveLowering_Q12" := FALSE;
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#2000ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 30;
	            END_IF;
	            
	        30: // Position oven feeder retract
	            IF "IX_MPO_RefSwitchOvenFeederOutside_I7" OR NOT "IX_MPO_RefSwitchOvenFeederInside_I6" THEN
	                "QX_MPO_M4_OvenFeederRetract_Q5" := TRUE;
	                "QX_MPO_M4_OvenFeederExtend_Q6" := FALSE;
	            ELSIF NOT "IX_MPO_RefSwitchOvenFeederOutside_I7" AND "IX_MPO_RefSwitchOvenFeederInside_I6" THEN
	                "QX_MPO_M4_OvenFeederRetract_Q5" := FALSE;
	                "QX_MPO_M4_OvenFeederExtend_Q6" := FALSE;
	                #li_StepCase := 40;
	            END_IF;
	            
	        40:  // Close door, Position Vacuum Towards Turn Table and vacuum off
	            
	            "QX_MPO_ValveOvenDoor_Q13" := FALSE;
	            
	            "QX_MPO_M5_VacuumTowardsTurnTable_Q8" := TRUE;
	            "QX_MPO_M5_VacuumTowardsOven_Q7" := FALSE;
	            "QX_MPO_ValveVacuum_Q11"        := FALSE;
	            
	            IF"IX_MPO_RefSwitchVac_PosOven_I8" OR NOT "IX_MPO_RefSwitchVac_PosTurnTable_I5" THEN
	                "QX_MPO_M5_VacuumTowardsTurnTable_Q8" := TRUE;
	                "QX_MPO_M5_VacuumTowardsOven_Q7" := FALSE;
	            ELSIF NOT "IX_MPO_RefSwitchVac_PosOven_I8" AND "IX_MPO_RefSwitchVac_PosTurnTable_I5" THEN
	                "QX_MPO_M5_VacuumTowardsTurnTable_Q8" := FALSE;
	                "QX_MPO_M5_VacuumTowardsOven_Q7" := FALSE;
	                #li_StepCase := 50;
	            END_IF
	            ;
	            
	        50: // saw, valve feeder conveyor belt off
	            "QX_MPO_M3_Saw_Q4" := FALSE;
	            "QX_MPO_ValveFeeder_Q14" := FALSE;
	            "QX_MPO_M2_ConveyorBeltForward_Q3" := FALSE;
	            
	            IF "IX_MPO_RefSwitchTurnTable_PosSaw_I4" OR "IX_MPO_RefSwitchTurnTable_PosBelt_I2" OR NOT "IX_MPO_RefSwitchTurnTable_PosVac_I1" THEN
	                "QX_MPO_M1_TurnTableClockwise_Q1" := FALSE;
	                "QX_MPO_M1_TurnTableCounterclockwise_Q2" := TRUE;
	            ELSIF NOT "IX_MPO_RefSwitchTurnTable_PosSaw_I4" AND NOT "IX_MPO_RefSwitchTurnTable_PosBelt_I2" AND "IX_MPO_RefSwitchTurnTable_PosVac_I1" THEN
	                "QX_MPO_M1_TurnTableClockwise_Q1" := FALSE;
	                "QX_MPO_M1_TurnTableCounterclockwise_Q2" := FALSE;
	                "QX_MPO_Compressor_Q10" := FALSE;
	                #li_StepCase := 60;
	            END_IF;
	            
	        60: // wait for request discard form VGR
	            #li_Lights := 1;
	            IF "gtyp_VGR".x_MPO_Req_Discard THEN
	                #li_Lights := 2;
	                "QX_MPO_Compressor_Q10" := TRUE;
	                #li_StepCase := 70;
	            END_IF;
	            
	        70: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 80;
	            END_IF;
	            
	        80: // open oven door
	            "QX_MPO_ValveOvenDoor_Q13" := TRUE;
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#2000ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 90;
	            END_IF;
	            
	        90: // oven feeder extend
	            "QX_MPO_M4_OvenFeederRetract_Q5"    := FALSE;
	            "QX_MPO_M4_OvenFeederExtend_Q6"     := TRUE;
	            
	            IF "IX_MPO_RefSwitchOvenFeederOutside_I7" AND NOT "IX_MPO_RefSwitchOvenFeederInside_I6" THEN
	                "QX_MPO_M4_OvenFeederRetract_Q5" := FALSE;
	                "QX_MPO_M4_OvenFeederExtend_Q6" := FALSE;
	                "gtyp_MPO".x_Discard_Ready      := TRUE;
	                #li_StepCase := 100;
	            END_IF;
	            
	        100: // wait for VGR discard workpiece
	            
	            #lx_Time_Error := TRUE;
	            
	            IF "gtyp_VGR".x_MPO_Discards AND "IX_MPO_LightBarrierOven_I9" THEN
	                "gtyp_Interface_Dashboard".Subscribe.State_MPO.x_active := TRUE;
	                "gtyp_MPO".History  := "gtyp_VGR".History;
	                "gtyp_MPO".Workpiece := "gtyp_VGR".Workpiece;
	                "gtyp_MPO".x_Discard_Ready := FALSE;
	                "gtyp_MPO".x_MPO_Discards_Accepted := TRUE;
	                #lx_Time_Error := FALSE;
	                #li_StepCase := 105;
	            END_IF;
	            
	            // runtime error
	            IF #lfb_TON_Error.Q THEN
	                #li_Lights := 4;
	                #lx_Time_Error := FALSE;
	                "gtyp_Interface_Dashboard".Subscribe.State_MPO.x_active := FALSE;
	                "gtyp_MPO".x_Error := TRUE;
	                #li_StepCase := 0;
	            END_IF;
	            
	        105: // VGR outside oven feeder - oven feeder retract
	            IF NOT "gtyp_VGR".x_MPO_Discards AND "IX_MPO_RefSwitchOvenFeederOutside_I7" AND NOT "IX_MPO_RefSwitchOvenFeederInside_I6" THEN
	                "QX_MPO_M4_OvenFeederRetract_Q5" := TRUE;
	                "QX_MPO_M4_OvenFeederExtend_Q6" := FALSE;
	                #li_StepCase := 110;
	            END_IF;
	            
	        110: // sensor oven feeder inside reached
	            IF NOT "IX_MPO_RefSwitchOvenFeederOutside_I7" AND "IX_MPO_RefSwitchOvenFeederInside_I6" THEN
	                "QX_MPO_M4_OvenFeederRetract_Q5" := FALSE;
	                "QX_MPO_M4_OvenFeederExtend_Q6" := FALSE;
	                #li_StepCase := 120;
	            END_IF;
	            
	        120: // close oven door
	            "QX_MPO_ValveOvenDoor_Q13" := FALSE;
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#2000ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 130;
	            END_IF;
	            
	        130: // processing time flashing interval
	            "QX_MPO_LightOven_Q9":= #lfb_blinker.outx_blinker;
	            
	            IF NOT "gtyp_VGR".x_MPO_Discards THEN
	                #li_Return_LDT := RD_SYS_T(#ldt_MQTT);
	                "gtyp_MPO".History[5].i_code := 500;
	                "gtyp_MPO".History[5].ldt_ts := DT_TO_LDT(#ldt_MQTT);
	                
	                "QX_MPO_M5_VacuumTowardsOven_Q7" := TRUE;
	                "QX_MPO_M5_VacuumTowardsTurnTable_Q8" := FALSE;
	                
	                IF NOT "IX_MPO_RefSwitchVac_PosTurnTable_I5" AND "IX_MPO_RefSwitchVac_PosOven_I8" THEN
	                    "QX_MPO_M5_VacuumTowardsOven_Q7" := FALSE;
	                    "QX_MPO_M5_VacuumTowardsTurnTable_Q8" := FALSE;
	                END_IF;
	            END_IF;
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#4000ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 140;
	            END_IF;
	            
	        140: // open oven door
	            "QX_MPO_LightOven_Q9"       := FALSE;
	            "QX_MPO_ValveOvenDoor_Q13"  := TRUE;
	            
	            IF NOT "gtyp_VGR".x_MPO_Discards THEN
	                "QX_MPO_M5_VacuumTowardsOven_Q7" := TRUE;
	                "QX_MPO_M5_VacuumTowardsTurnTable_Q8" := FALSE;
	                
	                IF NOT "IX_MPO_RefSwitchVac_PosTurnTable_I5" AND "IX_MPO_RefSwitchVac_PosOven_I8" THEN
	                    "QX_MPO_M5_VacuumTowardsOven_Q7" := FALSE;
	                    "QX_MPO_M5_VacuumTowardsTurnTable_Q8" := FALSE;
	                END_IF;
	            END_IF;
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#2000ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 150;
	            END_IF;
	            
	        150: // oven feeder extend
	            
	            "QX_MPO_M4_OvenFeederRetract_Q5" := FALSE;
	            "QX_MPO_M4_OvenFeederExtend_Q6" := TRUE;
	            
	            IF NOT "gtyp_VGR".x_MPO_Discards THEN
	                "QX_MPO_M5_VacuumTowardsOven_Q7" := TRUE;
	                "QX_MPO_M5_VacuumTowardsTurnTable_Q8" := FALSE;
	                
	                IF NOT "IX_MPO_RefSwitchVac_PosTurnTable_I5" AND "IX_MPO_RefSwitchVac_PosOven_I8" THEN
	                    "QX_MPO_M5_VacuumTowardsOven_Q7" := FALSE;
	                    "QX_MPO_M5_VacuumTowardsTurnTable_Q8" := FALSE;
	                END_IF;
	            END_IF;
	            
	            IF "IX_MPO_RefSwitchOvenFeederOutside_I7" AND NOT "IX_MPO_RefSwitchOvenFeederInside_I6" THEN
	                "QX_MPO_M4_OvenFeederRetract_Q5" := FALSE;
	                "QX_MPO_M4_OvenFeederExtend_Q6" := FALSE;
	            END_IF;
	            
	            IF "IX_MPO_RefSwitchOvenFeederOutside_I7" AND NOT "IX_MPO_RefSwitchOvenFeederInside_I6"
	                AND NOT "IX_MPO_RefSwitchVac_PosTurnTable_I5" AND "IX_MPO_RefSwitchVac_PosOven_I8" THEN
	                "QX_MPO_M5_VacuumTowardsOven_Q7" := FALSE;
	                "QX_MPO_M5_VacuumTowardsTurnTable_Q8" := FALSE;
	                "QX_MPO_M4_OvenFeederRetract_Q5" := FALSE;
	                "QX_MPO_M4_OvenFeederExtend_Q6" := FALSE;
	                #li_StepCase := 160;
	            END_IF;
	            
	        160: // vacuum suction device down
	            "QX_MPO_ValveLowering_Q12":= TRUE;
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#1000ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 170;
	            END_IF;
	            
	        170: // vacuum suction device picks up the workpiece
	            "QX_MPO_ValveVacuum_Q11":= TRUE;
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#1000ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 180;
	            END_IF;
	            
	        180: // vacuum suction device up
	            "QX_MPO_ValveLowering_Q12" := FALSE;
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#1000ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 190;
	            END_IF;
	            
	        190: // oven feeder retract and vacuum towards turn table
	            "QX_MPO_M4_OvenFeederRetract_Q5" := TRUE;
	            "QX_MPO_M4_OvenFeederExtend_Q6" := FALSE;
	            "QX_MPO_M5_VacuumTowardsOven_Q7" := FALSE;
	            "QX_MPO_M5_VacuumTowardsTurnTable_Q8" := TRUE;
	            
	            IF "IX_MPO_RefSwitchVac_PosTurnTable_I5" AND NOT "IX_MPO_RefSwitchVac_PosOven_I8" THEN
	                "QX_MPO_M5_VacuumTowardsOven_Q7" := FALSE;
	                "QX_MPO_M5_VacuumTowardsTurnTable_Q8" := FALSE;
	            END_IF;
	            
	            IF NOT "IX_MPO_RefSwitchOvenFeederOutside_I7" AND "IX_MPO_RefSwitchOvenFeederInside_I6" THEN
	                "QX_MPO_M4_OvenFeederRetract_Q5" := FALSE;
	                "QX_MPO_M4_OvenFeederExtend_Q6" := FALSE;
	            END_IF;
	            
	            IF NOT "IX_MPO_RefSwitchOvenFeederOutside_I7" AND "IX_MPO_RefSwitchOvenFeederInside_I6"
	                AND "IX_MPO_RefSwitchVac_PosTurnTable_I5" AND NOT "IX_MPO_RefSwitchVac_PosOven_I8" THEN
	                "QX_MPO_M5_VacuumTowardsOven_Q7" := FALSE;
	                "QX_MPO_M5_VacuumTowardsTurnTable_Q8" := FALSE;
	                "QX_MPO_M4_OvenFeederRetract_Q5" := FALSE;
	                "QX_MPO_M4_OvenFeederExtend_Q6" := FALSE;
	                "QX_MPO_ValveOvenDoor_Q13" := FALSE;
	                #li_StepCase := 200;
	            END_IF;
	            
	        200: // vacuum suction device down at turn table
	            IF "IX_MPO_RefSwitchTurnTable_PosVac_I1" THEN
	                "QX_MPO_ValveLowering_Q12" := TRUE;
	                
	                #lx_Start_TON_Wait := TRUE;
	                #lt_TON_Wait := T#2000ms;
	                
	                IF #lfb_TON_Wait.Q THEN
	                    #lx_Start_TON_Wait := FALSE;
	                    #li_StepCase := 210;
	                END_IF;
	            END_IF;
	            
	        210: // vacuum off
	            "QX_MPO_ValveVacuum_Q11" := FALSE;
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#2000ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 220;
	            END_IF;
	            
	        220: // vacuum suction device up
	            "QX_MPO_ValveLowering_Q12" := FALSE;
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#2000ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 230;
	            END_IF;
	            
	        230: // Position turn table saw
	            IF NOT "IX_MPO_RefSwitchTurnTable_PosSaw_I4" AND NOT "IX_MPO_RefSwitchTurnTable_PosBelt_I2" AND "IX_MPO_RefSwitchTurnTable_PosVac_I1" THEN
	                "QX_MPO_M1_TurnTableClockwise_Q1" := TRUE;
	                "QX_MPO_M1_TurnTableCounterclockwise_Q2" := FALSE;
	            ELSIF "IX_MPO_RefSwitchTurnTable_PosSaw_I4" OR "IX_MPO_RefSwitchTurnTable_PosBelt_I2" AND NOT "IX_MPO_RefSwitchTurnTable_PosVac_I1" THEN
	                "QX_MPO_M1_TurnTableClockwise_Q1" := FALSE;
	                "QX_MPO_M1_TurnTableCounterclockwise_Q2" := FALSE;
	                #li_StepCase := 240;
	            END_IF;
	            
	        240: // Start sawing
	            "QX_MPO_M3_Saw_Q4" := TRUE;
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#4000ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #li_Return_LDT := RD_SYS_T(#ldt_MQTT);
	                "gtyp_MPO".History[6].i_code := 600;
	                "gtyp_MPO".History[6].ldt_ts := DT_TO_LDT(#ldt_MQTT);
	                
	                #lx_Start_TON_Wait := FALSE;
	                "QX_MPO_M3_Saw_Q4" := FALSE;
	                #li_StepCase := 250;
	            END_IF;
	            
	        250: // Position turn table Pos Belt
	            IF "IX_MPO_RefSwitchTurnTable_PosSaw_I4" AND NOT "IX_MPO_RefSwitchTurnTable_PosBelt_I2" AND NOT "IX_MPO_RefSwitchTurnTable_PosVac_I1" THEN
	                "QX_MPO_M1_TurnTableClockwise_Q1" := TRUE;
	                "QX_MPO_M1_TurnTableCounterclockwise_Q2" := FALSE;
	            ELSIF NOT "IX_MPO_RefSwitchTurnTable_PosSaw_I4" AND "IX_MPO_RefSwitchTurnTable_PosBelt_I2" AND NOT "IX_MPO_RefSwitchTurnTable_PosVac_I1" THEN
	                "QX_MPO_M1_TurnTableClockwise_Q1" := FALSE;
	                "QX_MPO_M1_TurnTableCounterclockwise_Q2" := FALSE;
	                #li_StepCase := 260;
	            END_IF;
	            
	        260: // put workpiece to belt
	            "QX_MPO_ValveFeeder_Q14" := TRUE;
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#2000ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                "QX_MPO_ValveFeeder_Q14" := FALSE;
	                "QX_MPO_Compressor_Q10" := FALSE;
	                #li_StepCase := 270;
	            END_IF;
	            
	        270: // Position turn table Pos Vacuum
	            IF "IX_MPO_RefSwitchTurnTable_PosSaw_I4" OR "IX_MPO_RefSwitchTurnTable_PosBelt_I2" OR NOT "IX_MPO_RefSwitchTurnTable_PosVac_I1" THEN
	                "QX_MPO_M1_TurnTableClockwise_Q1" := FALSE;
	                "QX_MPO_M1_TurnTableCounterclockwise_Q2" := TRUE;
	            ELSIF NOT "IX_MPO_RefSwitchTurnTable_PosSaw_I4" AND NOT "IX_MPO_RefSwitchTurnTable_PosBelt_I2" AND "IX_MPO_RefSwitchTurnTable_PosVac_I1" THEN
	                "QX_MPO_M1_TurnTableClockwise_Q1" := FALSE;
	                "QX_MPO_M1_TurnTableCounterclockwise_Q2" := FALSE;
	                "QX_MPO_Compressor_Q10" := FALSE;
	                #li_StepCase := 280;
	            END_IF;
	            
	        280: // Start conveyor belt
	            "QX_MPO_M2_ConveyorBeltForward_Q3" := TRUE;
	            
	            #lx_Time_Error := TRUE;
	            
	            IF #lfb_TOF_ConveyerBelt_Out.Q THEN
	                "gtyp_SLD".History  := "gtyp_MPO".History;
	                "gtyp_SLD".Workpiece := "gtyp_MPO".Workpiece;
	                "gtyp_MPO".Workpiece.s_id := '0';
	                "gtyp_MPO".Workpiece.s_state := '';
	                "gtyp_MPO".Workpiece.s_type := '';
	                FOR #li_Counter := 1 TO 8 DO
	                    "gtyp_MPO".History[#li_Counter].i_code := 0;
	                    "gtyp_MPO".History[#li_Counter].ldt_ts := DT#1990-01-01-00:00:00;
	                END_FOR;
	                
	                "gtyp_Interface_Dashboard".Subscribe.State_MPO.x_active := FALSE;
	                
	                #lx_Time_Error := FALSE;
	                #li_StepCase := 290;
	            END_IF;
	            
	            // runtime error
	            IF #lfb_TON_Error.Q THEN
	                #li_Lights := 4;
	                #lx_Time_Error := FALSE;
	                "QX_MPO_M2_ConveyorBeltForward_Q3" := FALSE;
	                "gtyp_Interface_Dashboard".Subscribe.State_MPO.x_active := FALSE;
	                "gtyp_MPO".x_Error := TRUE;
	                #li_StepCase := 0;
	            END_IF;
	            
	        290: // wait for runtime on conveyor belt
	            
	            IF NOT #lfb_TOF_ConveyerBelt_Out.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                "QX_MPO_M2_ConveyorBeltForward_Q3" := FALSE;
	                #li_StepCase := 60;
	            END_IF;
	        // Statement section ELSE
	        ELSE  
	            ;
	    END_CASE;
	
	    "QW_MPO_PWM_TurnTable_M1"   := "gtyp_MPO"."i_PWM_TurnTable";
	    "QW_MPO_PWM_Vacuum_M5"      := "gtyp_MPO"."i_PWM_Vacuum";
	
	ELSE
	    #li_Lights := 1;
	    #lx_Init := TRUE;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "PRG_DSO_Status"
TITLE = Program Status DSO
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
   VAR 
      lx_Init { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Start { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      li_StepCase { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ldt_MQTT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Date_And_Time;
      li_Return_LDT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      li_code_old { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      lfb_R_Trig_Outsourcing {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      lfb_R_Trig_Take_Workpiece {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
      lfb_TON_Status {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      lfb_TON_End_Order {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      lx_StartStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_StartEndOrder { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_StartTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR


BEGIN
	IF #lx_Init THEN
	    
	    // wait time state
	    #lfb_TON_Status(IN := NOT #lx_StartStatus,
	                    PT := T#2s);
	    
	    // rising/falling edge light barrier DSI
	    #lfb_R_Trig_Outsourcing(CLK := NOT "IX_SSC_LightBarrierOutsourcing_I4");
	    #lfb_R_Trig_Take_Workpiece(CLK := "IX_SSC_LightBarrierOutsourcing_I4");
	    
	    // start wait time end order 
	    IF NOT "IX_SSC_LightBarrierOutsourcing_I4" AND ("gtyp_Interface_Dashboard".Subscribe.State_Order.s_state = 'SHIPPED') THEN
	        #lx_StartEndOrder := TRUE;
	    END_IF;
	    
	    // wait time end order
	    #lfb_TON_End_Order(IN := #lx_StartEndOrder,
	                       PT := T#5s);
	    
	    IF #lfb_R_Trig_Take_Workpiece.Q OR #lfb_TON_End_Order.Q THEN
	        #lx_StartEndOrder := FALSE;
	        "gtyp_Interface_Dashboard".Subscribe.State_Order.ldt_ts := DT_TO_LDT(#ldt_MQTT);
	        "gtyp_Interface_Dashboard".Subscribe.State_Order.s_state := 'WAITING_FOR_ORDER';
	        "gtyp_Interface_Dashboard".Subscribe.State_Order.s_type := '';
	        "gtyp_Interface_Dashboard".Subscribe.State_DSO.x_active := FALSE;
	    END_IF;
	    
	    // state of the DSO transmitted to the cloud
	    IF (#lfb_TON_Status.Q OR #lfb_R_Trig_Outsourcing.Q OR #lfb_R_Trig_Take_Workpiece.Q) AND NOT #lx_StartStatus THEN
	        #lx_StartStatus := TRUE;
	        #li_Return_LDT := RD_SYS_T(#ldt_MQTT);
	        IF NOT "IX_SSC_LightBarrierOutsourcing_I4" THEN
	            "gtyp_Interface_Dashboard".Subscribe.State_DSO.i_code := 0;
	        ELSE
	            "gtyp_Interface_Dashboard".Subscribe.State_DSO.i_code := 1;
	        END_IF;
	        "gtyp_Interface_Dashboard".Subscribe.State_DSO.ldt_ts := DT_TO_LDT(#ldt_MQTT);
	        "gtyp_Interface_Dashboard".Subscribe.State_DSO.s_station := 'dso';
	        "gtyp_Interface_Dashboard".Subscribe.State_DSO.s_target := '';
	        "gtyp_Interface_Dashboard".Subscribe.State_DSO.s_description := '';
	    END_IF;
	    
	    IF NOT #lfb_TON_Status.Q AND #lx_StartStatus THEN
	        #lx_StartStatus := FALSE;
	    END_IF;
	ELSE
	    #lx_Init := TRUE;
	    #lx_StartEndOrder := FALSE;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "PRG_SSC_Ablauf"
TITLE = Program Ablauf SSC
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
   VAR 
      lx_Init { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_FirstCentre { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Start { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Start_TON_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lt_TON_Wait { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;
      li_StepCase { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ldi_TargetPosition_Horizontal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      ldi_TargetPosition_Vertical { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      lldt_ts_old { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LDT;
      ldt_write { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Date_And_Time;
      li_Return_write { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ldt_MQTT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Date_And_Time;
      li_Return_LDT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      lx_Start_TON_Wait { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ldi_StepHorizontal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      ldi_StepVertical { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      lfb_TON_Wait {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      lfb_TON_State {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      lfb_F_TRIG_Set_Pos {InstructionName := 'F_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : F_TRIG;
   END_VAR


BEGIN
	IF #lx_Init THEN
	    
	    // Restart after set Positioning
	    IF "gtyp_Setup".x_Set_Pos_Activ THEN
	        #li_StepCase := 0;
	    END_IF;
	    
	    // falling edge Set Pos
	    #lfb_F_TRIG_Set_Pos(CLK:= "gtyp_Setup".x_Set_Pos_Activ);
	    
	    IF #lfb_F_TRIG_Set_Pos.Q THEN
	        #lx_FirstCentre := TRUE;
	    END_IF;
	    
	    #lfb_TON_Wait(IN := #lx_Start_TON_Wait,
	                     PT := #lt_TON_Wait);
	        
	    // wait time state
	    #lfb_TON_State(IN := NOT #lx_Start_TON_State,
	                   PT := T#2s);
	    
	    // state of the ssc cyclically transmitted to the cloud
	    IF #lfb_TON_State.Q AND NOT #lx_Start_TON_State THEN
	        #lx_Start_TON_State := TRUE;
	        #li_Return_LDT := RD_SYS_T(#ldt_MQTT);
	        "gtyp_Interface_Dashboard".Subscribe.PosPanTiltUnit.ldt_ts := DT_TO_LDT(#ldt_MQTT);
	    END_IF;
	    
	    // restart wait time state
	    IF NOT #lfb_TON_State.Q AND #lx_Start_TON_State THEN
	        #lx_Start_TON_State := FALSE;
	    END_IF;
	        
	    CASE #li_StepCase OF
	            
	        0:  // Init
	            #lx_Start_TON_State := FALSE;
	            "gtyp_SSC".Horizontal_Axis.x_Start_Positioning  := FALSE;
	            "gtyp_SSC".Vertical_Axis.x_Start_Positioning    := FALSE;
	            
	            IF NOT "gtyp_Setup".x_Set_Pos_Activ THEN
	                #li_StepCase := 10;
	            END_IF;
	            
	        10: // Deciding which route to take 
	            
	            IF ("gtyp_Interface_Dashboard".Publish.PosPanTiltUnit.ldt_ts > #lldt_ts_old) OR #lx_FirstCentre THEN
	                
	                #lldt_ts_old := "gtyp_Interface_Dashboard".Publish.PosPanTiltUnit.ldt_ts;
	                
	                // convert the degrees to position
	                #ldi_StepHorizontal := REAL_TO_DINT("FC_Scale_linear"(inr_Y1 := DINT_TO_REAL("gtyp_SSC".Horizontal_Axis.Config.di_Neg_Soft_Switch),
	                                                                                                          inr_Y2 := DINT_TO_REAL("gtyp_SSC".Horizontal_Axis.Config.di_Pos_Soft_Switch),
	                                                                                                          inr_X1 := 0.0,
	                                                                                                          inr_X2 := 180.0,
	                                                                                                          inr_X := DINT_TO_REAL("gtyp_Interface_Dashboard".Publish.PosPanTiltUnit.i_degree)));
	                #ldi_StepVertical := REAL_TO_DINT("FC_Scale_linear"(inr_Y1 := DINT_TO_REAL("gtyp_SSC".Vertical_Axis.Config.di_Neg_Soft_Switch),
	                                                                                                      inr_Y2 := DINT_TO_REAL("gtyp_SSC".Vertical_Axis.Config.di_Pos_Soft_Switch),
	                                                                                                      inr_X1 := 0.0,
	                                                                                                      inr_X2 := 180.0,
	                                                                                                      inr_X := DINT_TO_REAL("gtyp_Interface_Dashboard".Publish.PosPanTiltUnit.i_degree)));
	                // Procedure - relmove_left
	                IF ("gtyp_Interface_Dashboard".Publish.PosPanTiltUnit.s_cmd = 'relmove_left')
	                    AND (("gtyp_SSC".Horizontal_Axis.di_Actual_Position - #ldi_StepHorizontal) > "gtyp_SSC".Horizontal_Axis.Config.di_Neg_Soft_Switch + 15)
	                    AND NOT "IX_SSC_RefSwitchHorizontalAxis_I2" THEN
	                    #ldi_TargetPosition_Horizontal := "gtyp_SSC".Horizontal_Axis.di_Actual_Position - #ldi_StepHorizontal;
	                    "gtyp_SSC".Horizontal_Axis.di_Target_Position := #ldi_TargetPosition_Horizontal;
	                    "gtyp_SSC".Horizontal_Axis.x_Start_Positioning := TRUE;
	                    #li_StepCase := 70;
	                // Procedure - relmove_right
	                ELSIF ("gtyp_Interface_Dashboard".Publish.PosPanTiltUnit.s_cmd = 'relmove_right')
	                    AND (("gtyp_SSC".Horizontal_Axis.di_Actual_Position + #ldi_StepHorizontal) < "gtyp_SSC".Horizontal_Axis.Config.di_Pos_Soft_Switch - 15) THEN
	                    #ldi_TargetPosition_Horizontal := "gtyp_SSC".Horizontal_Axis.di_Actual_Position + #ldi_StepHorizontal;
	                    "gtyp_SSC".Horizontal_Axis.di_Target_Position := #ldi_TargetPosition_Horizontal;
	                    "gtyp_SSC".Horizontal_Axis.x_Start_Positioning := TRUE;
	                    #li_StepCase := 70;
	                // Procedure - relmove_up
	                ELSIF ("gtyp_Interface_Dashboard".Publish.PosPanTiltUnit.s_cmd = 'relmove_up')
	                    AND (("gtyp_SSC".Vertical_Axis.di_Actual_Position + #ldi_StepHorizontal) < "gtyp_SSC".Vertical_Axis.Config.di_Pos_Soft_Switch - 15) THEN
	                    #ldi_TargetPosition_Vertical := "gtyp_SSC".Vertical_Axis.di_Actual_Position + #ldi_StepVertical;
	                    "gtyp_SSC".Vertical_Axis.di_Target_Position := #ldi_TargetPosition_Vertical;
	                    "gtyp_SSC".Vertical_Axis.x_Start_Positioning := TRUE;
	                    #li_StepCase := 80;
	                // Procedure - relmove_down
	                ELSIF ("gtyp_Interface_Dashboard".Publish.PosPanTiltUnit.s_cmd = 'relmove_down')
	                    AND (("gtyp_SSC".Vertical_Axis.di_Actual_Position - #ldi_StepVertical) > "gtyp_SSC".Vertical_Axis.Config.di_Neg_Soft_Switch + 15)
	                    AND NOT "IX_SSC_RefSwitchVerticalAxis_I1" THEN
	                    #ldi_TargetPosition_Vertical := "gtyp_SSC".Vertical_Axis.di_Actual_Position - #ldi_StepVertical;
	                    "gtyp_SSC".Vertical_Axis.di_Target_Position := #ldi_TargetPosition_Vertical;
	                    "gtyp_SSC".Vertical_Axis.x_Start_Positioning := TRUE;
	                    #li_StepCase := 80;
	                // Procedure - first 
	                ELSIF #lx_FirstCentre THEN
	                    #li_StepCase := 20;
	                // Procedure - home
	                ELSIF ("gtyp_Interface_Dashboard".Publish.PosPanTiltUnit.s_cmd = 'home') THEN
	                    #li_StepCase := 60;
	                // Procedure - start_pan
	                ELSIF ("gtyp_Interface_Dashboard".Publish.PosPanTiltUnit.s_cmd = 'start_pan')
	                    AND ("gtyp_SSC".Horizontal_Axis.di_Actual_Position > "gtyp_SSC".Horizontal_Axis.Config.di_Neg_Soft_Switch + 15)
	                    AND NOT "IX_SSC_RefSwitchHorizontalAxis_I2" THEN
	                    #ldi_TargetPosition_Horizontal := "gtyp_SSC".Horizontal_Axis.Config.di_Neg_Soft_Switch + 15;
	                    "gtyp_SSC".Horizontal_Axis.di_Target_Position := #ldi_TargetPosition_Horizontal;
	                    "gtyp_SSC".Horizontal_Axis.x_Start_Positioning := TRUE;
	                    #li_StepCase := 70;
	                // Procedure - end_pan
	                ELSIF ("gtyp_Interface_Dashboard".Publish.PosPanTiltUnit.s_cmd = 'end_pan')
	                    AND ("gtyp_SSC".Horizontal_Axis.di_Actual_Position < "gtyp_SSC".Horizontal_Axis.Config.di_Pos_Soft_Switch - 15) THEN
	                    #ldi_TargetPosition_Horizontal := "gtyp_SSC".Horizontal_Axis.Config.di_Pos_Soft_Switch - 15;
	                    "gtyp_SSC".Horizontal_Axis.di_Target_Position := #ldi_TargetPosition_Horizontal;
	                    "gtyp_SSC".Horizontal_Axis.x_Start_Positioning := TRUE;
	                    #li_StepCase := 70;
	                // Procedure - start_tilt
	                ELSIF ("gtyp_Interface_Dashboard".Publish.PosPanTiltUnit.s_cmd = 'start_tilt')
	                    AND ("gtyp_SSC".Vertical_Axis.di_Actual_Position > "gtyp_SSC".Vertical_Axis.Config.di_Neg_Soft_Switch + 15)
	                    AND NOT "IX_SSC_RefSwitchVerticalAxis_I1" THEN
	                    #ldi_TargetPosition_Vertical := "gtyp_SSC".Vertical_Axis.Config.di_Neg_Soft_Switch + 15;
	                    "gtyp_SSC".Vertical_Axis.di_Target_Position := #ldi_TargetPosition_Vertical;
	                    "gtyp_SSC".Vertical_Axis.x_Start_Positioning := TRUE;
	                    #li_StepCase := 80;
	                // Procedure - end_tilt
	                ELSIF ("gtyp_Interface_Dashboard".Publish.PosPanTiltUnit.s_cmd = 'end_tilt')
	                    AND ("gtyp_SSC".Vertical_Axis.di_Actual_Position < "gtyp_SSC".Vertical_Axis.Config.di_Pos_Soft_Switch - 15) THEN
	                    #ldi_TargetPosition_Vertical := "gtyp_SSC".Vertical_Axis.Config.di_Pos_Soft_Switch - 15;
	                    "gtyp_SSC".Vertical_Axis.di_Target_Position := #ldi_TargetPosition_Vertical;
	                    "gtyp_SSC".Vertical_Axis.x_Start_Positioning := TRUE;
	                    #li_StepCase := 80;
	                END_IF;
	            END_IF;
	            
	        20: // homing vertical/horizontal axis
	            "gtyp_SSC".Horizontal_Axis.x_Reference  := TRUE;
	            "gtyp_SSC".Vertical_Axis.x_Reference    := TRUE;
	            
	            IF NOT "gtyp_SSC".Horizontal_Axis.x_Referenced AND NOT "gtyp_SSC".Vertical_Axis.x_Referenced THEN
	               #li_StepCase := 30;
	            END_IF;
	            
	        30: // homed vertical/horizontal axis
	            IF "gtyp_SSC".Horizontal_Axis.x_Referenced THEN
	                "gtyp_SSC".Horizontal_Axis.x_Reference := FALSE;
	            END_IF;
	            IF "gtyp_SSC".Vertical_Axis.x_Referenced THEN
	                "gtyp_SSC".Vertical_Axis.x_Reference := FALSE;
	            END_IF;
	            
	            IF "gtyp_SSC".Horizontal_Axis.x_Referenced AND "gtyp_SSC".Vertical_Axis.x_Referenced THEN
	                "gtyp_SSC".Horizontal_Axis.x_Reference := FALSE;
	                "gtyp_SSC".Vertical_Axis.x_Reference := FALSE;
	                #lx_Start_TON_Wait := TRUE;
	                #li_StepCase := 40;
	            END_IF;
	            
	        40: // wait sequence
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 50;
	            END_IF;
	            
	        50: // Position horizontal/vertical axis and reached
	            "gtyp_SSC".Horizontal_Axis.di_Target_Position   := "gtyp_SSC".di_Pos_HBW_Horizontal;
	            "gtyp_SSC".Horizontal_Axis.x_Start_Positioning  := TRUE;
	            "gtyp_SSC".Vertical_Axis.di_Target_Position     := "gtyp_SSC".di_Pos_HBW_Vertical;
	            "gtyp_SSC".Vertical_Axis.x_Start_Positioning    := TRUE;
	            
	            IF ("gtyp_SSC".Horizontal_Axis.di_Actual_Position <= ("gtyp_SSC".di_Pos_HBW_Horizontal + "gtyp_SSC".Horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_SSC".Horizontal_Axis.di_Actual_Position >= ("gtyp_SSC".di_Pos_HBW_Horizontal - "gtyp_SSC".Horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_SSC".Horizontal_Axis.x_Position_Reached THEN
	                "gtyp_SSC".Horizontal_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_SSC".Vertical_Axis.di_Actual_Position <= ("gtyp_SSC".di_Pos_HBW_Vertical + "gtyp_SSC".Vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_SSC".Vertical_Axis.di_Actual_Position >= ("gtyp_SSC".di_Pos_HBW_Vertical - "gtyp_SSC".Vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_SSC".Vertical_Axis.x_Position_Reached THEN
	                "gtyp_SSC".Vertical_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_SSC".Horizontal_Axis.di_Actual_Position <= ("gtyp_SSC".di_Pos_HBW_Horizontal + "gtyp_SSC".Horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_SSC".Horizontal_Axis.di_Actual_Position >= ("gtyp_SSC".di_Pos_HBW_Horizontal - "gtyp_SSC".Horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_SSC".Horizontal_Axis.x_Position_Reached
	                AND ("gtyp_SSC".Vertical_Axis.di_Actual_Position <= ("gtyp_SSC".di_Pos_HBW_Vertical + "gtyp_SSC".Vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_SSC".Vertical_Axis.di_Actual_Position >= ("gtyp_SSC".di_Pos_HBW_Vertical - "gtyp_SSC".Vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_SSC".Vertical_Axis.x_Position_Reached THEN
	                "gtyp_SSC".Horizontal_Axis.x_Start_Positioning := FALSE;
	                "gtyp_SSC".Vertical_Axis.x_Start_Positioning := FALSE;
	                #lx_FirstCentre := FALSE;
	                #li_StepCase := 90;
	            END_IF;
	            
	        60: // Position Centre horizontal/vertical axis and reached
	            "gtyp_SSC".Horizontal_Axis.di_Target_Position := "gtyp_SSC".di_Pos_Centre_Horizontal;
	            "gtyp_SSC".Horizontal_Axis.x_Start_Positioning := TRUE;
	            "gtyp_SSC".Vertical_Axis.di_Target_Position := "gtyp_SSC".di_Pos_Centre_Vertical;
	            "gtyp_SSC".Vertical_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_SSC".Horizontal_Axis.di_Actual_Position <= ("gtyp_SSC".di_Pos_Centre_Horizontal + "gtyp_SSC".Horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_SSC".Horizontal_Axis.di_Actual_Position >= ("gtyp_SSC".di_Pos_Centre_Horizontal - "gtyp_SSC".Horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_SSC".Horizontal_Axis.x_Position_Reached THEN
	                "gtyp_SSC".Horizontal_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_SSC".Vertical_Axis.di_Actual_Position <= ("gtyp_SSC".di_Pos_Centre_Vertical + "gtyp_SSC".Vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_SSC".Vertical_Axis.di_Actual_Position >= ("gtyp_SSC".di_Pos_Centre_Vertical - "gtyp_SSC".Vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_SSC".Vertical_Axis.x_Position_Reached THEN
	                "gtyp_SSC".Vertical_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_SSC".Horizontal_Axis.di_Actual_Position <= ("gtyp_SSC".di_Pos_Centre_Horizontal + "gtyp_SSC".Horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_SSC".Horizontal_Axis.di_Actual_Position >= ("gtyp_SSC".di_Pos_Centre_Horizontal - "gtyp_SSC".Horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_SSC".Horizontal_Axis.x_Position_Reached
	                AND ("gtyp_SSC".Vertical_Axis.di_Actual_Position <= ("gtyp_SSC".di_Pos_Centre_Vertical + "gtyp_SSC".Vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_SSC".Vertical_Axis.di_Actual_Position >= ("gtyp_SSC".di_Pos_Centre_Vertical - "gtyp_SSC".Vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_SSC".Vertical_Axis.x_Position_Reached THEN
	                "gtyp_SSC".Horizontal_Axis.x_Start_Positioning := FALSE;
	                "gtyp_SSC".Vertical_Axis.x_Start_Positioning := FALSE;
	                #lx_FirstCentre := FALSE;
	                #li_StepCase := 90;
	            END_IF;
	            
	        70: // Position horizontal axis reached
	            IF ("gtyp_SSC".Horizontal_Axis.di_Actual_Position <= (#ldi_TargetPosition_Horizontal + "gtyp_SSC".Horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_SSC".Horizontal_Axis.di_Actual_Position >= (#ldi_TargetPosition_Horizontal - "gtyp_SSC".Horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_SSC".Horizontal_Axis.x_Position_Reached THEN
	                "gtyp_SSC".Horizontal_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 90;
	            END_IF;
	            
	        80: // Position vertical axis reached
	            IF ("gtyp_SSC".Vertical_Axis.di_Actual_Position <= (#ldi_TargetPosition_Vertical + "gtyp_SSC".Vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_SSC".Vertical_Axis.di_Actual_Position >= (#ldi_TargetPosition_Vertical - "gtyp_SSC".Vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_SSC".Vertical_Axis.x_Position_Reached THEN
	                "gtyp_SSC".Vertical_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 90;
	            END_IF;
	            
	        90: // convert the position to degrees
	            "gtyp_Interface_Dashboard".Subscribe.PosPanTiltUnit.r_pan := "FC_Scale_linear"(inr_Y1 := -1.0,
	                                                                                           inr_Y2 := 1.0,
	                                                                                           inr_X1 := DINT_TO_REAL("gtyp_SSC".Horizontal_Axis.Config.di_Neg_Soft_Switch),
	                                                                                           inr_X2 := DINT_TO_REAL("gtyp_SSC".Horizontal_Axis.Config.di_Pos_Soft_Switch),
	                                                                                           inr_X := "gtyp_SSC".Horizontal_Axis.di_Actual_Position);
	            "gtyp_Interface_Dashboard".Subscribe.PosPanTiltUnit.r_tilt:= "FC_Scale_linear"(inr_Y1 := -1.0,
	                                                                                           inr_Y2 := 1.0,
	                                                                                           inr_X1 := DINT_TO_REAL("gtyp_SSC".Vertical_Axis.Config.di_Neg_Soft_Switch),
	                                                                                           inr_X2 := DINT_TO_REAL("gtyp_SSC".Vertical_Axis.Config.di_Pos_Soft_Switch),
	                                                                                           inr_X := "gtyp_SSC".Vertical_Axis.di_Actual_Position);
	            
	            #li_Return_write := RD_SYS_T(#ldt_write);
	            "gtyp_Interface_Dashboard".Subscribe.PosPanTiltUnit.ldt_ts := DT_TO_LDT(#ldt_write);
	            #lx_Start_TON_Wait := TRUE;
	            #li_StepCase := 100;
	            
	        100:// wait sequence
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 0;
	            END_IF;
	    // Statement section ELSE        
	    ELSE  
	        ;
	    END_CASE;
	 
	ELSE
	    #lx_Init := TRUE;
	    #lx_FirstCentre := TRUE;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "PRG_Acknowledge"
TITLE = Program Acknowledge
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
   VAR 
      lx_Init { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      li_StepCase { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      lldt_Ack_old { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LDT;
      lfb_TON_Wait {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      lx_Start_TON_Wait { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR


BEGIN
	IF #lx_Init THEN
	    #lfb_TON_Wait(IN:= #lx_Start_TON_Wait,PT:= T#20s);
	    
	    CASE #li_StepCase OF
	            
	        0:  // Init
	            #lx_Start_TON_Wait := FALSE;
	            
	            // check whether acknowledgment has been pressed (time stamp changes)
	            IF ("gtyp_Interface_Dashboard".Publish.ldt_AcknowledgeButton > #lldt_Ack_old)
	                OR "gtyp_Setup".x_AcknowledgeButton THEN
	                #lldt_Ack_old    := "gtyp_Interface_Dashboard".Publish.ldt_AcknowledgeButton;
	                #li_StepCase    := 10;
	            END_IF;
	            
	        10: // acknowledge Errors
	            "gtyp_HBW".x_Error := FALSE;
	            "gtyp_MPO".x_Error := FALSE;
	            "gtyp_SLD".x_Error := FALSE;
	            #li_StepCase := 20;
	            
	        20: // Reset acknowledge button
	            "gtyp_Setup".x_AcknowledgeButton := FALSE;
	            #li_StepCase := 0;
	    // Statement section ELSE
	    ELSE  
	        ;
	    END_CASE;
	 
	ELSE
	    #lx_Init := TRUE;
	END_IF;
END_FUNCTION_BLOCK

DATA_BLOCK "RT_INFO_scl_OB30"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
   VAR 
      mode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Mode 1 = Runtime of a specific OB; 2 = Maximum runtime of a specific OB; 3 = Minimum runtime of a specific OB; 10 = Mean value of the percentage of total runtime used by higher-priority OBs; ...
      obNbr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : OB_ANY;   // OB to read
      infoData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LTime;   // mode 1 --> Runtime in LTIME
      returnValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Error information of instruction
   END_VAR


BEGIN
   mode := 1;
   obNbr := 1;

END_DATA_BLOCK

DATA_BLOCK "PRG_SSC_Ablauf_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"PRG_SSC_Ablauf"

BEGIN

END_DATA_BLOCK

DATA_BLOCK "PRG_VGR_Axis_rotate_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"PRG_VGR_Axis_rotate"

BEGIN

END_DATA_BLOCK

DATA_BLOCK "PRG_SSC_Axis_Vertical_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"PRG_SSC_Axis_Vertical"

BEGIN

END_DATA_BLOCK

DATA_BLOCK "PRG_VGR_Ablauf_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"PRG_VGR_Ablauf"

BEGIN

END_DATA_BLOCK

DATA_BLOCK "PRG_SSC_Axis_Horizontal_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"PRG_SSC_Axis_Horizontal"

BEGIN

END_DATA_BLOCK

DATA_BLOCK "PRG_VGR_Axis_vertical_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"PRG_VGR_Axis_vertical"

BEGIN

END_DATA_BLOCK

DATA_BLOCK "PRG_SSC_Light_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"PRG_SSC_Light"

BEGIN

END_DATA_BLOCK

DATA_BLOCK "PRG_HBW_Ablauf_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"PRG_HBW_Ablauf"

BEGIN

END_DATA_BLOCK

DATA_BLOCK "PRG_NFC_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"PRG_NFC"

BEGIN

END_DATA_BLOCK

DATA_BLOCK "PRG_HBW_Set_Positioning_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"PRG_HBW_Set_Positioning"

BEGIN

END_DATA_BLOCK

DATA_BLOCK "RT_INFO_scl_OB1"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
   VAR 
      mode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Mode 1 = Runtime of a specific OB; 2 = Maximum runtime of a specific OB; 3 = Minimum runtime of a specific OB; 10 = Mean value of the percentage of total runtime used by higher-priority OBs; ...
      obNbr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : OB_ANY;   // OB to read
      infoData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LTime;   // mode 1 --> Runtime in LTIME
      returnValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Error information of instruction
   END_VAR


BEGIN
   mode := 1;
   obNbr := 1;

END_DATA_BLOCK

DATA_BLOCK "PRG_Acknowledge_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"PRG_Acknowledge"

BEGIN

END_DATA_BLOCK

DATA_BLOCK "PRG_DSO_Status_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"PRG_DSO_Status"

BEGIN

END_DATA_BLOCK

DATA_BLOCK "PRG_DSI_Status_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"PRG_DSI_Status"

BEGIN

END_DATA_BLOCK

DATA_BLOCK "PRG_Order_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"PRG_Order"

BEGIN

END_DATA_BLOCK

DATA_BLOCK "PRG_SLD_Ablauf_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"PRG_SLD_Ablauf"

BEGIN

END_DATA_BLOCK

DATA_BLOCK "PRG_SSC_Set_Positioning_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"PRG_SSC_Set_Positioning"

BEGIN

END_DATA_BLOCK

DATA_BLOCK "PRG_MPO_Ablauf_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"PRG_MPO_Ablauf"

BEGIN

END_DATA_BLOCK

DATA_BLOCK "PRG_SSC_Calibration_Color_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"PRG_SSC_Calibration_Color"

BEGIN

END_DATA_BLOCK

DATA_BLOCK "PRG_HBW_Axis_Horizontal_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"PRG_HBW_Axis_Horizontal"

BEGIN

END_DATA_BLOCK

DATA_BLOCK "PRG_HBW_Axis_Vertical_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"PRG_HBW_Axis_Vertical"

BEGIN

END_DATA_BLOCK

DATA_BLOCK "PRG_VGR_Set_Positioning_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"PRG_VGR_Set_Positioning"

BEGIN

END_DATA_BLOCK

DATA_BLOCK "PRG_SLD_Calibration_Color_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"PRG_SLD_Calibration_Color"

BEGIN

END_DATA_BLOCK

DATA_BLOCK "PRG_SLD_Set_Counter_Values_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"PRG_SLD_Set_Counter_Values"

BEGIN

END_DATA_BLOCK

DATA_BLOCK "PRG_VGR_Axis_horizontal_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"PRG_VGR_Axis_horizontal"

BEGIN

END_DATA_BLOCK

ORGANIZATION_BLOCK "Main"
TITLE = "Main Program Sweep (Cycle)"
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0

BEGIN
	// current cycle Time OB30
	"RT_INFO_scl_OB30".mode := 1;
	"RT_INFO_scl_OB30".obNbr := 30;
	"RT_INFO_scl_OB30".returnValue := RT_INFO(MODE := "RT_INFO_scl_OB30".mode,
	                                          OB := "RT_INFO_scl_OB30".obNbr,
	                                          INFO := "RT_INFO_scl_OB30".infoData);
	
	// current cycle Time OB1
	"RT_INFO_scl_OB1".mode := 1;
	"RT_INFO_scl_OB1".obNbr := 1;
	"RT_INFO_scl_OB1".returnValue := RT_INFO(MODE := "RT_INFO_scl_OB1".mode,
	                                         OB := "RT_INFO_scl_OB1".obNbr,
	                                         INFO := "RT_INFO_scl_OB1".infoData);
	
	// sources SSC
	"PRG_SSC_Ablauf_DB"();
	"PRG_SSC_Set_Positioning_DB"();
	"PRG_SSC_Calibration_Color_DB"();
	"PRG_SSC_Axis_Vertical_DB"();
	"PRG_SSC_Axis_Horizontal_DB"();
	"PRG_SSC_Light_DB"();
	
	// sources VGR
	"PRG_VGR_Ablauf_DB"();
	"PRG_VGR_Set_Positioning_DB"();
	"PRG_VGR_Axis_horizontal_DB"();
	"PRG_VGR_Axis_vertical_DB"();
	"PRG_VGR_Axis_rotate_DB"();
	"PRG_NFC_DB"();
	
	// sources HBW
	"PRG_HBW_Ablauf_DB"();
	"PRG_HBW_Set_Positioning_DB"();
	"PRG_HBW_Axis_Vertical_DB"();
	"PRG_HBW_Axis_Horizontal_DB"();
	
	// sources MPO
	"PRG_MPO_Ablauf_DB"();
	
	// sources SLD
	"PRG_SLD_Ablauf_DB"();
	"PRG_SLD_Calibration_Color_DB"();
	"PRG_SLD_Set_Counter_Values_DB"();
	
	// sources input/output
	"PRG_DSI_Status_DB"();
	"PRG_DSO_Status_DB"();
	
	// sources dashboard
	"PRG_Order_DB"();
	"PRG_Acknowledge_DB"();
	
END_ORGANIZATION_BLOCK

